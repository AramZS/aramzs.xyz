---
author: Lea Verou
cover_image: 'https://lea.verou.me/blog/2026/web-deps/images/intervention.png'
date: '2026-01-12T18:26:51.301Z'
dateFolder: 2026/01/12
description: >-
  Dear JS ecosystem, I love you, but you have a dependency management problem
  when it comes to the Web, and the time has come for an intervention.
isBasedOn: 'https://lea.verou.me/blog/2026/web-deps/'
link: 'https://lea.verou.me/blog/2026/web-deps/'
slug: 2026-01-12-httpsleaveroumeblog2026web-deps
tags:
  - code
  - tech
title: Web dependencies are broken. Can we fix them?
---
<p>Dear JS ecosystem, I love you, but you have a dependency management problem when it comes to the Web, and the time has come for an intervention.</p>
<figure><img alt="A cartoon where JS is shown hanging out drinking with bundlers. Webpack is saying ‚Äújust one more config!‚Äù and Vite and Rollup are saying ‚ÄúWe can optimize this!‚Äù. The event looks like it's winding down after hours of depravity. On the right side, a group of fed up developers are holding up an ‚ÄúIntervention‚Äù banner." src="https://lea.verou.me/blog/2026/web-deps/images/intervention.png"/><figcaption>A cartoon where JS is shown hanging out drinking with bundlers. Webpack is saying ‚Äújust one more config!‚Äù and Vite and Rollup are saying ‚ÄúWe can optimize this!‚Äù. The event looks like it's winding down after hours of depravity. On the right side, a group of fed up developers are holding up an ‚ÄúIntervention‚Äù banner.</figcaption></figure>
<p><strong>Abstraction</strong> is the cornerstone of modern software engineering. Reusing logic and building higher-level solutions from lower-level building blocks is what makes all the technological wonders around us possible. Imagine if every time anyone wrote a calculator they also had to reinvent floating-point arithmetic and string encoding!</p>
<p>And yet, <strong>the web platform has outsourced this fundamental functionality to third-party tooling</strong>. As a result, code reuse has become a balancing of tradeoffs that should not have existed in the first place.</p>
<p>In NodeJS, you just <code>npm install</code> and reference specifiers straight away in your code. Same in Python, with <code>pip install</code>. Same in Rust with <code>cargo add</code>. In healthy ecosystems you don‚Äôt ponder how or whether to use dependencies. The ecosystem assumes <strong>dependencies are normal, cheap, and first-class</strong>. You just install them, use them, and move on. <strong>‚ÄúDependency-free‚Äù is not a badge of honor.</strong></p>
<p>Instead, dependency management in the web platform consists of <strong>bits and bobs of scattered primitives, with no coherent end-to-end solution</strong>. Naturally, bundlers such as <a href="https://webpack.js.org/">Webpack</a>, <a href="https://rollupjs.org/">rollup</a>, and <a href="https://esbuild.github.io/">esbuild</a> have picked up the slack, with <a href="https://browserify.org/">browserify</a> being the one that started it all, in 2012.</p>
<p>There is <strong>nothing wrong with bundlers</strong> when used as a <strong>performance optimization</strong> to minimize waterfall effects and overhead from too many HTTP requests. You know, what a <em>bundler</em> is supposed to do. It is okay to require <strong>advanced tools for advanced needs</strong>, and performance optimization is generally an advanced use case. Same for most other things bundlers and build tools are used for, such as strong typing, linting, or transpiling. All of these are needs that come much later than dependency management, both in a programmer‚Äôs learning journey, as well as in a project‚Äôs development lifecycle.</p>
<p>Dependency management is such a basic and ubiquitous need, it should be a part of the platform, decoupled from bundling. Requiring <strong>advanced tools for basic needs is a textbook <a href="https://lea.verou.me/blog/2025/user-effort/#cliffs">usability cliff</a></strong>. In other ecosystems, optimizations happen (and are learned) after dependency resolution. <strong>On the web, optimization is the price of admission!</strong> This is not normal.</p>
<p>Bundlers have become so ubiquitous that most JS developers cannot even imagine deploying code without them. READMEs are written assuming a bundler, without even mentioning the assumption. <strong>It‚Äôs just how JS is consumed.</strong> My heart breaks for the newbie trying to use a drag and drop library, only to get mysterious errors about specifiers that failed to resolve.</p>
<p>However, bundling is not <em>technically</em> a necessary step of dependency management. Importing files through URLs is natively supported in every browser, via ESM imports. HTTP/2 makes importing multiple small files far more reasonable than it used to be ‚Äî at least from a connection overhead perspective. <strong>You can totally get by without bundlers in a project that doesn‚Äôt use any libraries.</strong></p>
<p><strong>But the moment you add that first dependency, everything changes.</strong> You are suddenly faced with a huge <a href="https://lea.verou.me/blog/2025/user-effort/#cliffs">usability cliff</a>: which bundler to use, how to configure it, how to deploy with it, a mountain of decisions standing between you and your goal of using that one dependency. That one drag and drop library. For newcomers, this often comes very early in their introduction to the web platform, and it can be downright overwhelming.</p>
<p>It <em>is</em> technically possible to use dependencies without bundlers, today. There are a few different approaches, and ‚Äî I will not sugarcoat it ‚Äî <strong>they all suck</strong>.</p>
<p>There are three questions here:</p>
<ol> <li>Use specifiers or URLs?</li> <li>How to resolve specifiers to URLs?</li> <li>Which URL do my dependencies live at?</li> </ol>
<p>There is currently no good answer to any of them, only fragile workarounds held together by duct tape.</p>
<p>Using a dependency should not need any additional song and dance besides ‚Äúinstall this package‚Äù + ‚Äúnow import it here‚Äù. That‚Äôs it. That‚Äôs the <a href="https://lea.verou.me/blog/2025/user-effort/#signal-to-noise">minimum necessary to declare intent</a>. And that‚Äôs <em>precisely</em> how it works in NodeJS and other JS runtimes. Anything beyond that is reducing <a href="https://lea.verou.me/blog/2025/user-effort/#signal-to-noise">signal-to-noise ratio</a>, especially if it needs to be done separately for every project or worse, for every dependency.</p>
<p>You may need to have something to bite hard on while reading the next few sections. It‚Äôs going to be <em>bad</em>.</p>
<p>Typically, package managers like <code>npm</code> take care of deduplicating compatible package versions and may use a directory like <code>node_modules</code> to install packages. <strong>In theory, one could deploy <code>node_modules/</code></strong> as part of their website and directly reference files in client-side JS. For example, to use <a href="https://vuejs.org/">Vue</a>:</p>
<pre><code>import { createApp } from "../node_modules/vue/dist/vue.esm-browser.js";</code></pre>
<p>It works out of the box, and is a very natural thing to try the first time you install a package and you notice <code>node_modules</code>. Great, right?</p>
<p>No. Not great.</p>
<p>First, deploying your entire <code>node_modules</code> directory is both <strong>wasteful</strong>, and a <strong>security risk</strong>. In fact, most serverless hosts (e.g. <a href="https://www.netlify.com/">Netlify</a> or <a href="https://vercel.com/">Vercel</a>) automatically remove it from the publicly deployed files after the build is finished.</p>
<p>Additionally, it <strong>violates encapsulation</strong>: paths within a package are generally seen as an implementation detail of the package itself, and packages expose <em>specifier exports</em> like <code>vue</code> or <code>colorjs.io/fn</code> that <em>they</em> map to internal paths. If you decide to circumvent this and link to files directly, you now need to update your import paths whenever you update the package.</p>
<p>It is also fragile, as not every module is installed directly in <code>node_modules/</code> ‚Äî though those explicitly marked as app dependencies are.</p>
<p>Another common path is importing from CDNs like <a href="https://unpkg.com/">Unpkg</a> and <a href="https://www.jsdelivr.com/">JSDelivr</a>. For Vue, it would look like this:</p>
<pre><code>import { createApp } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";</code></pre>
<p>It‚Äôs quick and easy. Nothing to install or configure! Great, right?</p>
<p>No. Not great.</p>
<p><strong>It is always a bad idea to introduce a dependency on a whole other domain you do not control</strong>, and an even worse one when linking to executable code.</p>
<p>First, there is the obvious security risk. Unless you link to a specific version, down to the patch number and/or use <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Defenses/Subresource_Integrity">SRI</a>, the resource could turn malicious overnight under your nose if the package is compromised. And even if you link to a specific version, there is always the risk that the CDN itself could get compromised. Who remembers <a href="https://blog.qualys.com/vulnerabilities-threat-research/2024/06/28/polyfill-io-supply-chain-attack">polyfill.io</a>?</p>
<p>But even supply-chain attacks aside, any third-party domain is an unnecessary <strong>additional point of failure</strong>. I still remember scrambling to change <a href="https://www.jsdelivr.com/">JSDelivr</a> URLs to <a href="https://unpkg.com/">Unpkg</a> during an outage right before one of my talks, or having to hunt down all my repos that used <a href="https://rawgit.com/">RawGit</a> URLs when it sunset, including many libraries.</p>
<p>The DX is also suboptimal. <strong>You lose the immediacy and resilience of local, relative paths.</strong> Without additional tooling (<a href="https://requestly.com/">Requestly</a>, <code>hosts</code> file edits, etc.), you now need to wait for CDN roundtrips even during local development. Wanted to code on a flight? Good luck. Needed to show a live demo during a talk, over clogged conference wifi? Maybe sacrifice a goat to the gods first.</p>
<p>And while they maintain encapsulation slightly better than raw file imports, as they let you reference a package by its name for its default export, additional specifiers (e.g. <code>packagename/fn</code>) typically still require importing by file path.</p>
<p><em>‚ÄúBut with public CDNs, I benefit from the resource having already been cached by another website the user visited!‚Äù</em><br/>
 Oh my sweet summer child. I hate to be the one to break it to you, but no, you don‚Äôt, and that has been the case <a href="https://addyosmani.com/blog/double-keyed-caching/">since about 2020</a>. <strong><em>Double keyed caching</em> obliterated this advantage</strong>.</p>
<p>A quick and dirty way to get local URLs for local development and CDN URLs for the remote site is to link to relative <code>./node_modules</code> URLs, and add a URL rewrite to a CDN if that is not found. E.g. with <a href="https://docs.netlify.com/manage/routing/redirects/overview/">Netlify rewrites</a> this looks like this:</p>
<pre><code>node_modules/:modulename/* https://cdn.jsdelivr.net/npm/:modulename@latest/:splat 301</code></pre>
<p>Since <code>node_modules</code> is not deployed, this will always redirect on the remote URL, while still allowing for local URLs during development. Great, right?</p>
<p>No. Not great.</p>
<p>Like the mythical hydra, it solves one problem and creates two new ones.</p>
<p>First, it still carries many of the same issues of the approaches it combines:</p>
<ul> <li>Linking to CDNs is inherently insecure</li> <li>It breaks encapsulation of the dependencies</li> </ul>
<p>Additionally, it introduces a new problem: the two files need to match, but the na√Øve approach above would always just link to the latest version.</p>
<p>Sure, one could alleviate this by building the <code>_redirects</code> file with tooling, to link to specific versions, read from <code>package-lock.json</code>. But the point is not that it‚Äôs insurmountable, but that <strong>it should not be this hard</strong>.</p>
<p>Another solution is a lightweight build script that copies either entire packages or specific exports into a directory that <em>will</em> actually get deployed. When dependencies are few, this can be as simple as an npm script:</p>
<pre><code>{
	"scripts": {
		"lib": "cp node_modules/vue/dist/vue.esm-browser.js common/lib/vue.js",
		"build": "npm run lib"
	}
}</code></pre>
<p>So now we have our own nice subset of <code>node_modules/</code> and we don‚Äôt depend on any third-party domains. Great, right?</p>
<p>No. Not great.</p>
<p>Just like most other solution, this still breaks encapsulation, forcing us to maintain a separate, ad-hoc index of specifiers to file paths.</p>
<p>Additionally, it has no awareness of the dependency graph. Dependencies of dependencies need to be copied separately. But wait a second. Did I say dependencies of dependencies? <em>How would that even work?</em></p>
<p>In addition to their individual flaws, <em>all</em> of the solutions above share a major flaw: <strong>they can only handle importing dependency-free packages</strong>. But what happens if the package you‚Äôre importing also uses dependencies? It gets unimaginably worse my friend, that‚Äôs what happens.</p>
<p><strong>There is no reasonable way for a library author to link to dependencies without excluding certain consumer workflows.</strong> There is no local URL a library author can use to reliably link to dependencies, and CDN URLs are highly problematic. Specifiers are the only way here.</p>
<p>So the moment you include a dependency that uses dependencies, you‚Äôre <strong>forced into specifier-based dependency management workflows</strong>, whether these are bundlers, or import map flavored JSON vomit in every single HTML page (discussed later).</p>
<h3><a href="https://lea.verou.me/blog/2026/web-deps/#%E2%80%9Cbrowser%E2%80%9D-bundles">‚ÄúBrowser‚Äù bundles</a></h3>
<p>As a fig leaf, libraries will often provide a ‚Äúbrowser‚Äù bundle that consumers can import instead of their normal <code>dist</code>, which does not use specifiers. This combines all <em>their</em> dependencies into a single dependency-free file that you can import from a browser. This means they can use whatever dependencies they want, and you can still import that bundle using regular ESM imports in a browser, sans bundler. <em>Great, right?</em></p>
<p>No. Not great.</p>
<p>It‚Äôs called a <em>bundle</em> for a reason. It <em>bundles</em> all their dependencies too, and now they cannot be shared with any other dependency in your tree, even if it‚Äôs exactly the same version of exactly the same package. <strong>You‚Äôre not avoiding bundling, you‚Äôre outsourcing it</strong>, and multiplying the size of your JS code in the process.</p>
<p>And if the library author has <em>not</em> done that, you‚Äôre stuck with little to do, besides a CDN that rewrites specifiers on the fly like <a href="https://esm.sh/">esm.sh</a>, with all CDN downsides described above.</p>
<p>As someone who regularly releases open source packages (<a href="https://npm-stat.com/charts.html?package=prismjs&amp;from=2012-01-01">some with billions of npm installs</a>), I find this incredibly frustrating. <strong>I want to write packages that can be consumed by people using or not using bundlers, without penalizing either group</strong>, but the only way to do that today is to basically not use any dependencies. I cannot even modularize <em>my own</em> packages without running into this! <em>This doesn‚Äôt scale.</em></p>
<p>Browsers <em>can</em> import specifiers, as long as the mapping to a URL is explicitly provided through an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap">import map</a>. Import maps look like this:</p>
<pre><code>&lt;script type="importmap"&gt;
{
	"imports": {
		"vue": "./node_modules/vue/dist/vue.runtime.esm-bundler.js",
		"lodash": "./node_modules/lodash-es/lodash.js",
	}
}
&lt;/script&gt;</code></pre>
<p>Did you notice something? Yes, this is an HTML block. No, I cannot link to an import map that lives in a separate file. Instead, I have to include the darn thing in. Every. Single. Page. <strong>The moment you decide to use JS dependencies, you now need an HTML templating tool as well.</strong> üôÉ</p>
<p>‚Äúüí° <em>Oh I know, I‚Äôll generate this from my library via DOM methods!</em>‚Äù I hear you say. No, my sweet summer child. <strong>It needs to be present at parse time.</strong> So unless you‚Äôre willing to <code>document.write()</code> it (please don‚Äôt), the answer is a big flat NOPE.</p>
<p>‚Äúüí° <em>Ok, at least I‚Äôll keep it short by routing everything through a CDN or the same local folder</em>‚Äù No, my sweet summer child. Go to sleep and dream of <a href="https://github.com/whatwg/html/issues/11919">globs</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLPattern">URLPatterns</a>. Then wake up and get to work, because you actually need to specify. Every. Single. Mapping. Yes, transitive dependencies too.</p>
<figure><img alt="Yo dawg meme with the text ‚ÄúYo Dawg, I heard you like dependencies, so I put the deps of your deps in your import maps‚Äù" src="https://lea.verou.me/blog/2026/web-deps/images/yo-dawg.png"/><img alt="Ursula from The Little Mermaid singing ‚ÄúIt‚Äôs sad, but true. If you want to use dependencies, my sweet you gotta pay the toll‚Äù to the tune of ‚ÄúPoor Unfortunate Souls‚Äù" src="https://lea.verou.me/blog/2026/web-deps/images/ursula-toll.png"/><figcaption>Ursula from The Little Mermaid singing ‚ÄúIt‚Äôs sad, but true. If you want to use dependencies, my sweet you gotta pay the toll‚Äù to the tune of ‚ÄúPoor Unfortunate Souls‚Äù</figcaption></figure>
<p><strong>So now I need a build tool to manage the import map</strong>, like <a href="https://jspm.org/">JSPM</a>. It also needs to talk to my HTML templating tool, which I now had to add so it can spit out these import maps on. Every. Single. HTML. Page.</p>
<p>There are three invariants that import maps violate:</p>
<ol> <li><strong>Locality</strong>: Dependency declarations live in HTML, not JS. Libraries cannot declare their own dependencies.</li> <li><strong>Composability</strong>: Import maps do not compose across dependencies and require global coordination</li> <li><strong>Scalability</strong>: Mapping every transitive dependency is not viable without tooling</li> </ol>
<p>Plus, you still have all of the issues discussed above, because you still need URLs to link to. <strong>By trying to solve your problem with import maps, you now got multiple problems.</strong></p>
<p>To sum up, in their current form, <strong>import maps don‚Äôt eliminate bundlers</strong> ‚Äî they recreate them in JSON form, while adding an HTML dependency and worse latency.</p>
<h2><a href="https://lea.verou.me/blog/2026/web-deps/#are-bundlers-the-lesser-evil%3F">Are bundlers the lesser evil?</a></h2>
<p>Given the current state of the ecosystem, not using bundlers in any nontrivial application does seem like an exercise in masochism. Indeed, per <a href="https://2024.stateofjs.com/en-US/libraries/build_tools/">State of JS 2024</a>, bundlers were extremely popular, with Webpack having been used by 9 in 10 developers and having close to 100% awareness! But sorting by sentiment paints a different picture, with satisfaction, interest, and positivity dropping year after year. Even those who never question the status quo can feel it in their gut that this is not okay. This is not a reasonable way to manage dependencies. <strong>This is not a healthy ecosystem.</strong></p>
<p>Out of curiosity, I also ran two polls on my own social media. Obviously, this suffers from <a href="https://en.wikipedia.org/wiki/Selection_bias">selection bias</a>, due to the <a href="https://en.wikipedia.org/wiki/Snowball_sampling">snowball sampling</a> nature of social media, but I was still surprised to see such a high percentage of bundle-less JS workflows:</p>
<ul> <li><a href="https://x.com/LeaVerou/status/2008341499461743048">Twitter/X poll</a>: 17.6% of respondents</li> <li><a href="https://front-end.social/@leaverou/115840120189230465">Mastodon poll</a>: 40% (!) of respondents</li> </ul>
<p>I‚Äôm very curious how these folks manage the problems discussed here.</p>
<p>Oftentimes when discussing these issues, I get the question ‚Äúbut other languages are completely compiled, why is it a problem here?‚Äù. <strong>Yes, but their compiler is official and always there.</strong> You literally can‚Äôt use the language without it.</p>
<p><strong>The problem is not compilation, it‚Äôs fragmentation.</strong> It‚Äôs the experience of linking to a package via a browser import only to see errors about specifiers. It‚Äôs adding mountains of config and complexity to use a utility function. It‚Äôs having no clear path to write a package that uses another package, even if both are yours.</p>
<p><strong>Abstraction itself is not something to outsource</strong> to third-party tools. This is the programming equivalent of privatizing fundamental infrastructure ‚Äî roads, law enforcement, healthcare ‚Äî systems that work precisely because everyone can rely on them being there.</p>
<p>Like <a href="https://en.wikipedia.org/wiki/Boiling_frog">boiling frogs</a>, <strong>JS developers have resigned themselves to immense levels of complexity and gruntwork</strong> as simply <em>how things are</em>. The rise of AI introduced swaths of less technical folks to web development and their overwhelm and confusion is forcing us to take a long hard look at the current shape of the ecosystem ‚Äî and it‚Äôs not pretty.</p>
<p>Few things must always be part of a language‚Äôs standard library, but dependency management is absolutely one of them. Any cognitive overhead should be going into deciding <em>which</em> library to use, not <em>whether</em> to include it and <em>how</em>.</p>
<p>This is also actively <strong>harming web platform architecture</strong>. Because bundlers are so ubiquitous, we have ended up designing the platform around them, when it should be the opposite. For example, because <code>import.meta.url</code> is unreliable when bundlers are used, components have no robust way to link to other resources (styles, images, icons, etc.) relative to themselves, unless these resources can be part of the module tree. So now we are adding features to the web platform that break any reasonable assumption about what HTML, CSS, and JS are, like JS imports for CSS and HTML, which could have been a simple <code>fetch()</code> if web platform features could be relied on.</p>
<p>And because using dependencies is nontrivial, we are adding features to the standard library that could have been userland or even browser-provided dependencies.</p>
<p>To reiterate, <strong>the problem isn‚Äôt that bundlers exist</strong> ‚Äî it‚Äôs that they are the only viable way to get first-class dependency management on the web.</p>
<p><strong>JS developers deserve better. The web platform deserves better.</strong></p>
<p>As a web standards person, my first thought when spotting such a lacking is ‚Äúhow can the web platform improve?‚Äù. And after four years in the <a href="https://en.wikipedia.org/wiki/Technical_Architecture_Group">TAG</a>, I cannot shake the holistic architectural perspective of <em><strong>‚Äúwhich part of the Web stack is best suited for this?‚Äù</strong></em></p>
<p>Before we can fix this, we need to understand why it is the way it is. <strong>What is the fundamental reason the JS ecosystem overwhelmingly prefers specifiers over URLs?</strong></p>
<p>On the surface, people often quote syntax, but that seems to be a red herring. There is little DX advantage of <code>foo</code> (a specifier) over <code>./foo.js</code> (a URL), or even <code>./foo</code> (which can be configured to have a JS MIME type). Another oft-cited reason is immutability: Remote URLs can change, whereas specifiers cannot. This also appears to be a red herring: local URLs can be just as immutable as specifiers.</p>
<p>Digging deeper, it seems that the more fundamental reason has to do with <strong>purview</strong>. A URL is largely the same everywhere, whereas <code>foo</code> can resolve to different things depending on context. A specifier is app-controlled whereas a URL is not. <strong>There needs to be a standard location for a dependency to be located and referenced from, and that needs to be app-controlled.</strong></p>
<p>Additionally, <strong>specifiers are universal</strong>. Once a package is installed, it can be imported from anywhere, without having to work out paths. The closest HTTP URLs can get to this is root-relative URLs, and that‚Äôs still not quite the same.</p>
<p>Specifiers are clearly the path of least resistance here, so the low hanging fruit would be to make it easier to map specifiers to URLs, starting by improving import maps.</p>
<h3><a href="https://lea.verou.me/blog/2026/web-deps/#improving-import-maps">Improving import maps</a></h3>
<p>An area with huge room for improvement here is <strong>import maps</strong>. Both making it easier to generate and include import maps, and making the import maps themselves smaller, leaner, and easier to maintain.</p>
<p>The biggest need here is <strong>external import maps</strong>, even if it‚Äôs only via <code>&lt;script type=importmap src&gt;</code>. This would eliminate the dependency on HTML templating and opens the way for generating them with a simple build tool.</p>
<p>This was actually <a href="https://github.com/WICG/import-maps/issues/235">part of the original import map work</a>, and was removed from the spec due to lack of implementer interest, despite overwhelming demand. In 2022, external import maps were prototyped in WebKit (Safari), which prompted <a href="https://github.com/whatwg/html/issues/8355">a new WHATWG issue</a>. Unfortunately, it appears that progress has since stalled once more.</p>
<p>External import maps do alleviate some of the core pain points, but are still globally managed in HTML, which hinders composability and requires heavier tooling.</p>
<p><a href="https://es.discourse.group/t/bringing-import-maps-to-js-import-importmap-json-with-type-importmap/2481">What if import maps could be imported into JS code?</a> If JS could import import maps, (e.g. via <code>import "map.json" with { type: "importmap" }</code>), this would eliminate the dependency on HTML altogether, allowing for scripts to localize their own import info, and for the graph to be progressively composed instead of globally managed.</p>
<p>Going further, import maps via an HTTP header (e.g. <code>Link</code>) would even allow webhosts to generate them for you and send them down the wire completely transparently. <strong>This could be the final missing piece for making dependencies truly first-class.</strong></p>
<p>Imagine a future where you just install packages and use specifiers without setting anything up, without compiling any files into other files, with <strong>the server transparently handling the mapping</strong>!</p>
<p>However, import maps need URLs to map specifiers to, so we also need some way to deploy the relevant subset of <code>node_modules</code> to public-facing URLs, as deploying the entire <code>node_modules</code> directory is not a viable option.</p>
<h4><a href="https://lea.verou.me/blog/2026/web-deps/#clientdependencies-in-package.json%3F"><code>clientDependencies</code> in <code>package.json</code>?</a></h4>
<p>One solution might be <a href="https://github.com/openjs-foundation/package-metadata-interoperability-collab-space/issues/49">a way to explicitly mark dependencies as client side</a>, possibly even specific exports. This would decouple detection from processing app files: in complex apps it can be managed via tooling, and in simple apps it could even be authored manually, since it would only include top-level dependencies.</p>
<p>Even if we had better ways to mark which dependencies are client-side and map specifiers to URLs, these are still pieces of the puzzle, not the entire puzzle. Without a way to figure out what depends on what, transitive dependencies will still need to be managed globally at the top level, defeating any hope of a tooling-light workflow.</p>
<p>The current system relies on reading and parsing thousands of <code>package.json</code> files to build the dependency graph. This is reasonable for a JS runtime where the cost of file reads is negligible, but not for a browser where HTTP roundtrips are costly. And even if it were, this does not account for any tree-shaking.</p>
<p>Think of how this works when using URLs: modules simply link to other URLs and the graph is progressively composed through these requests. What if specifiers could work the same way? What if we could look up and route specifiers when they are actually imported?</p>
<p>Here‚Äôs a radical idea: <strong>What if specifiers were just another type of URL</strong>, and specifier resolution could be handled by the server in the same way a URL is resolved when it is requested? They could use a <code>specifier:</code> protocol, that can be omitted in certain contexts, such as ESM imports.</p>
<p>How would these URLs be different than regular local URLs?</p>
<ul> <li>Their protocol would be implied in certain contexts ‚Äî that would be how we can import bare specifiers in ESM</li> <li>Their resolution would be customizable (e.g. through import maps, or even regular URL rewrites)</li> <li>Despite looking like absolute URLs, their resolution would depend on the request‚Äôs <code>Origin</code> header (thus allowing different modules to use different versions of the same dependency). A request to a <code>specifier:</code> URL without an <code>Origin</code> header would fail.</li> <li>HTTP caching would work differently; basically in a way that emulates the current behavior of the JS module cache.</li> </ul>
<p>Architecturally, this has several advantages:</p>
<ul> <li>It <strong>bridges the gap between specifiers and URLs</strong>. Rather than having two entirely separate primitives for linking to a resource, it makes specifiers a high-level primitive and URLs the low-level primitive that explains it.</li> <li>It allows <strong>retrofitting specifiers into parts of the platform</strong> that were not designed for them, such as CSS <code>@import</code>. This is not theoretical: I was at a session at TPAC where bringing specifiers to CSS was discussed. With this, every part of the platform that takes URLs can now utilize specifiers, it would just need to specify the protocol explicitly.</li> </ul>
<p>Obviously, this is just a loose strawman at this point, and would need a lot of work to turn into an actual proposal (which I‚Äôd be happy to help out with, with <a href="https://lea.verou.me/consulting/webplatform/">funding</a>), but I suspect we need some way to bridge the gap between these two fundamentally different ways to import modules.</p>
<p>Too radical? Quite likely. But abstraction is foundational, and you often need radical solutions to fix foundational problems. Even if this is not the right path, I doubt incremental improvements can get us out of this mess for good.</p>
<p>But in the end, <strong>this is about the problem</strong>. I‚Äôm much more confident that the <em>problem</em> needs solving, than I am of any particular solution. Hopefully, after reading this, so are you.</p>
<p>So this is a call to action for the community. To browser vendors, to standards groups, to individual developers. <strong>Let‚Äôs fix this!</strong> üí™üèº</p>
<p><em>Thanks to <a href="https://github.com/ljharb">Jordan Harband</a>, <a href="https://www.wesleytodd.com/">Wes Todd</a>, and <a href="https://annevankesteren.nl/">Anne van Kesteren</a> for reviewing earlier versions of this draft.</em></p>
<h2>Reactions</h2>
