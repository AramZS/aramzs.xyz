---
author: Notion
cover_image: 'https://www.notion.so/images/meta/default.png'
date: '2026-02-20T16:10:39.064Z'
dateFolder: 2026/02/20
description: >-
  A new tool that blends your everyday work apps into one. It's the all-in-one
  workspace for you and your team
isBasedOn: >-
  https://martinkl.notion.site/Block-elements-in-rich-text-CRDT-for-Peritext-2-a3b69f886dbc4ad1abe81cea0b3e6623
link: >-
  https://martinkl.notion.site/Block-elements-in-rich-text-CRDT-for-Peritext-2-a3b69f886dbc4ad1abe81cea0b3e6623
slug: >-
  2026-02-20-httpsmartinklnotionsiteblock-elements-in-rich-text-crdt-for-peritext-2-a3b69f886dbc4ad1abe81cea0b3e6623
tags:
  - code
  - tech
title: Block elements in rich text CRDT (for Peritext 2)
---
<p>Need to support features:</p>
<ul><li>Block elements like &lt;p&gt;, &lt;ul&gt;&lt;li&gt;, &lt;ol&gt;&lt;li&gt;, &lt;h1&gt;, &lt;section&gt;, &lt;aside&gt;, &lt;blockquote&gt;, etc.</li><li>Nesting of those elements to arbitrary depth</li><li>Splitting and joining paragraphs without anomalies such as duplicated text</li><li>Converting one block type to another (e.g. paragraph to bullet point or heading)</li><li>Marks (e.g. comments) that cross a paragraph boundary</li><li>Tables that allow rows and columns to be added or removed</li></ul>
<p>I propose handling tables differently from other block elements, as explained below.</p>
<h3 data-content-editable-leaf="true">Non-tabular block elements</h3>
<p>New insight: we should not think about manipulating blocks; rather, the objects we're manipulating are the boundaries between blocks (where one block ends and the next one starts). Then the content of a block is just the text between one boundary and the next. This makes splitting and joining blocks easy: splitting means adding a boundary, and joining means removing a boundary.</p>
<p>I suggest that we keep the entire text of the document (excluding text in tables, see below) in a single plain text CRDT such as RGA. We add three a new CRDT operation types:</p>
<ul><li>splitBlock is similar to an insert, except that instead of adding a character to the text, it adds a special block boundary marker element to the sequence of characters. The splitBlock operation has some additional fields to indicate the block type and other properties (discussed below).</li><li>joinBlock is similar to a remove operation; it marks a block boundary as deleted (identified by the opId of a prior splitBlock operation) without actually removing it from the RGA sequence.</li><li>updateBlock modifies the properties of an existing block boundary, identified by the opId of a prior splitBlock operation. For example, this can change a &lt;p&gt; block into a &lt;h1&gt; block, or change the attributes of a &lt;p&gt; block from text-align: left to text-align: justify. Multiple concurrent updates of the same property of the same block boundary are resolved by last writer wins using opIds.</li></ul>
<p>To render the document in a text editor, the text from one non-deleted block boundary to the next non-deleted block boundary becomes the content of a block, and the type and properties of that block are determined by the properties of its starting boundary. The text between the beginning of the document and the first block boundary (if any) becomes a &lt;p&gt; block with default properties.</p>
<p>Why does splitBlock insert a marker element into the sequence? Because this makes it easy to handle blocks with empty text content. Moreover, if two users concurrently perform a splitBlock at the same position in the document, but with different properties (e.g. one user inserts a &lt;h1&gt; while the other inserts a &lt;h2&gt;), having a marker element ensures that all users end up with the same blocks in the same order.</p>
<p>This approach has no problems with a mark that spans block boundaries. For example, if someone hits enter in the middle of a bold span, that's just fine: there is still only one bold span, and that span just happens to now contain a block boundary. When the CRDT state is mapped to the text editor state, the bold span will get split into the portion that appears in one paragraph and the portion that appears in the next paragraph, but this split is just part of the rendering of the CRDT state. Conceptually there is just one bold span.</p>
<h3 data-content-editable-leaf="true">Bulleted/numbered lists</h3>
<p>The description so far works for a document that is a flat sequence of block elements, but it does not explain how to handle nesting of elements. Let's look at that next. The challenge with nesting is how to handle operations that change the tree structure.</p>
<p>As example, take a list with three bullet points:</p>
<pre data-block-id="9221d5e9-e86c-4952-8261-ba0ad3c95fb5">&lt;ul&gt;<br/>&lt;li&gt;one&lt;/li&gt;<br/>&lt;li&gt;two&lt;/li&gt;<br/>&lt;li&gt;three&lt;/li&gt;<br/>&lt;/ul&gt;<br/>​</pre>
<p>If a user positions their cursor on the middle element and clicks the "bullet point" toggle button in the UI, this has the effect of turning the middle element into a paragraph that is outside of the list, like this:</p>
<pre data-block-id="bf2ad331-c571-454a-9812-31bd84fab2b6">&lt;ul&gt;<br/>&lt;li&gt;one&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;p&gt;two&lt;/p&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;three&lt;/li&gt;<br/>&lt;/ul&gt;<br/>​</pre>
<p>Note that one &lt;ul&gt; has become two. And if the user clicks the same button again, it seems reasonable to assume that we should revert back to the original state in which there is a single &lt;ul&gt; with three &lt;li&gt; elements.</p>
<p>The fact that the &lt;ul&gt; can be split and merged like this suggests to me that we don't actually want an operation that creates the &lt;ul&gt; element explicitly. Rather, we should treat the &lt;li&gt; elements as our blocks, and create &lt;ul&gt; elements on the fly at rendering time whenever we encounter an &lt;li&gt;, because you can't have an &lt;li&gt; without a surrounding &lt;ul&gt; or &lt;ol&gt;. A property of the &lt;li&gt; block indicates whether it belongs to a bulleted or numbered list. Whenever we have several adjacent &lt;li&gt; blocks we combine them together into one &lt;ul&gt; or &lt;ol&gt;; when an &lt;li&gt; block is followed by another block type such as &lt;p&gt;, we insert a &lt;/ul&gt; or &lt;/ol&gt; after the &lt;li&gt;.</p>
<p>This approach would make it difficult to construct two lists that are adjacent but separate, like this:</p>
<pre data-block-id="423e8bba-097c-4569-918a-8a38fef25bf6">&lt;ul&gt;<br/>&lt;li&gt;one&lt;/li&gt;<br/>&lt;li&gt;two&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;three&lt;/li&gt;<br/>&lt;li&gt;four&lt;/li&gt;<br/>&lt;/ul&gt;<br/>​</pre>
<p>…but I suspect that is rarely what people would want anyway — more likely that people actually want the four bullet points in a single list. And if we really need adjacent but separate lists, we could have a "force-new-list" property on &lt;li&gt;three&lt;/li&gt; that causes us to insert a &lt;/ul&gt;&lt;ul&gt; even though &lt;li&gt;two&lt;/li&gt; and &lt;li&gt;three&lt;/li&gt; are adjacent.</p>
<h3 data-content-editable-leaf="true">Nested blocks</h3>
<p>Next, we need to add support for nested structures, such as nested lists:</p>
<pre data-block-id="4e757cda-cbf1-4bb0-a2e1-337a75f2d67d">&lt;ol&gt;<br/>&lt;li&gt;<br/>&lt;p&gt;1&lt;/p&gt;<br/>&lt;ol&gt;<br/>&lt;li&gt;1(a)&lt;/li&gt;<br/>&lt;li&gt;1(b)&lt;/li&gt;<br/>&lt;/ol&gt;<br/>&lt;/li&gt;<br/>&lt;li&gt;<br/>&lt;p&gt;2&lt;/p&gt;<br/>&lt;ol&gt;<br/>&lt;li&gt;2(a)&lt;/li&gt;<br/>&lt;li&gt;2(b)&lt;/li&gt;<br/>&lt;/ol&gt;<br/>&lt;/li&gt;<br/>&lt;/ol&gt;<br/>​</pre>
<p>or structural elements such as sidebars:</p>
<pre data-block-id="97a56cfc-1c1e-4e7e-ad14-c86d39e4b64b">&lt;h1&gt;My article&lt;/h2&gt;<br/>&lt;p&gt;Main text&lt;/p&gt;<br/>&lt;aside&gt;<br/>&lt;h3&gt;Sidebar title&lt;/h3&gt;<br/>&lt;p&gt;Sidebar text&lt;/p&gt;<br/>&lt;/aside&gt;<br/>&lt;p&gt;Main text continues&lt;/p&gt;<br/>​</pre>
<p>Like with list elements earlier, we need to support certain structural modifications that rich text editors make easy: for example, it is common to use tab and shift-tab to increase or decrease the nesting level of a bullet point, allowing the user to quickly toggle back and forth between these two structures:</p>
<blockquote>My list:<ol><li>One</li><li>Two</li><li>Three</li></ol></blockquote>
<blockquote>My list:<ol><li>One<ol><li>Two</li></ol></li><li>Three</li></ol></blockquote>
<p>If we represent this nesting level change as a complex set of operations involving creating or removing a nested list object, and moving an &lt;li&gt; back and forth between the outer and inner lists, I think the result will get very messy if there are concurrent edits. Instead, we should aim to have a representation that captures the nesting level change in the simplest way possible.</p>
<p>I propose the following representation: every block boundary has a property parents, which contains an array of block types that are parent blocks of this particular block. A top-level block has an empty parents array. A top-level bullet point or ordered list item also has an empty parents array (the &lt;ol&gt; or &lt;ul&gt; wrapper around the &lt;li&gt; is not regarded as a parent, because it's only added at rendering time). A nested list item that appears inside another list item would have something like parents: ["list-item"]. A paragraph that appears inside a sidebar, like in the example above, would have parents: ["aside"].</p>
<p>Note that we deliberately only list what kinds of parents we want, but not their identity (such as an opId). If we did reference the identity of the parents, there would be all sorts of awkward edge cases to deal with. For example, let's say we identify a block by the opId of the splitBlock operation that created the boundary at the start of the block. Then let's say we have a nested list with the following structure:</p>
<blockquote>My list:<ol><li>One</li><li>Two<ol><li>Three</li></ol></li></ol></blockquote>
<p>If block Three listed the ID of block Two as its parent, a user could position the cursor at the end of the item One, and hit the delete key, joining One and Two into a single list element. That list element would then presumably have the ID of the splitBlock operation that created One, and so the parent ID of Three would become invalid. On the other hand, if block Three simply has the property parents: ["list-item"], and the block that precedes it is a top-level list item, then Three becomes a child of whatever list item precedes it.</p>
<p>However, it could happen that the block that precedes Three is not a list item — perhaps because it was deleted, or because a user changed it into a different block type. For example, a user may change that last example by setting Two to be a paragraph block rather than a list item. The resulting document looks like this:</p>
<blockquote>My list:<ol><li>One</li></ol>Two<ol><li>Three</li></ol></blockquote>
<p>which should be rendered like this:</p>
<pre data-block-id="cb8184bd-751e-438d-8b26-8fb1633355de">&lt;p&gt;My list:&lt;/p&gt;<br/>&lt;ol&gt;&lt;li&gt;One&lt;/li&gt;&lt;/ol&gt;<br/>&lt;p&gt;Two&lt;/p&gt;<br/>&lt;ol&gt;&lt;li&gt;&lt;ol&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;<br/>​</pre>
<p>and have the following CRDT structure:</p>
<pre data-block-id="19a18a9e-1515-479d-898d-7f96147c9e07">{splitBlock blockType: "p", parents: []}<br/>My list<br/>{splitBlock blockType: "list-item", parents: []}<br/>One<br/>{splitBlock blockType: "p", parents: []}<br/>Two<br/>{splitBlock blockType: "list-item", parents: ["list-item"]}<br/>Three<br/>​</pre>
<p>You see that the child has become separated from its former parent, but that's fine — we just fill in new parent elements in the HTML rendering, much like we implicitly created the surrounding &lt;ol&gt; or &lt;ul&gt; for list elements in the last section.</p>
<p>I think this approach maps pretty well to the way rich text editors behave in practice, even though it seems a bit alien if you are coming at the problem from the perspective of the HTML DOM. It has the nice property that most updates are simple and local: for example, changing the nesting level of a list element is just a matter of updating its parents property, nothing else.</p>
<p>We always group consecutive blocks together under a common parent if their parents properties match. In the example above where the &lt;aside&gt; has a &lt;h3&gt; child and a &lt;p&gt; child, we would give both the &lt;h3&gt; block and the &lt;p&gt; block a property of parents: ["aside"]. This assumes that we want to put them in the same aside; it's not clear how we would represent two separate asides that just immediately happen to follow one after another. (If there is a top-level block, such as a paragraph, between the two asides, then it would be clear that we're talking about two separate asides.) But this feels like the earlier example of two bulleted lists with two bullet points each, which in most cases probably should be a single bulleted list with four points. Likewise, two asides that immediately follow each other might sensibly be a single aside. If this isn't the case, perhaps we need some kind of explicit break to indicate the start of a new aside.</p>
<h3 data-content-editable-leaf="true">Worked example</h3>
<p>The following document:</p>
<blockquote>List<ol><li>One</li><li>Two</li><li>Three</li></ol></blockquote>
<p>could be created by the following operations:</p>
<pre data-block-id="03e81121-e7f7-41eb-b6ef-323b9a673bf8">[<br/>{opId: "1@A", action: "insert", afterId: null, char: "L"},<br/>{opId: "2@A", action: "insert", afterId: "1@A", char: "i"},<br/>{opId: "3@A", action: "insert", afterId: "2@A", char: "s"},<br/>{opId: "4@A", action: "insert", afterId: "3@A", char: "t"},<br/>{opId: "5@A", action: "splitBlock", afterId: "4@A", blockType: "li", parents: [], style: "numbers"},<br/>{opId: "6@A", action: "insert", afterId: "5@A", char: "O"},<br/>{opId: "7@A", action: "insert", afterId: "6@A", char: "n"},<br/>{opId: "8@A", action: "insert", afterId: "7@A", char: "e"},<br/>{opId: "9@A", action: "splitBlock", afterId: "8@A", blockType: "li", parents: [], style: "numbers"},<br/>{opId: "10@A", action: "insert", afterId: "9@A", char: "T"},<br/>{opId: "11@A", action: "insert", afterId: "10@A", char: "W"},<br/>{opId: "12@A", action: "insert", afterId: "11@A", char: "o"},<br/>{opId: "13@A", action: "splitBlock", afterId: "12@A", blockType: "li", parents: [], style: "numbers"},<br/>{opId: "14@A", action: "insert", afterId: "13@A", char: "T"},<br/>{opId: "15@A", action: "insert", afterId: "14@A", char: "h"},<br/>{opId: "16@A", action: "insert", afterId: "15@A", char: "r"},<br/>{opId: "17@A", action: "insert", afterId: "16@A", char: "e"},<br/>{opId: "18@A", action: "insert", afterId: "17@A", char: "e"}<br/>]<br/>​</pre>
<p>To increase the nesting level of the middle element, resulting in the following document:</p>
<blockquote>List<ol><li>One<ol><li>Two</li></ol></li><li>Three</li></ol></blockquote>
<p>would require just one operation:</p>
<pre data-block-id="1b4c3e36-6633-470e-ad7c-5578d590f8b5">{opId: "19@A", action: "updateBlock", updatedId: "9@A", parents: ["li"], style: "abc"}<br/>​</pre>
<p>Changing the middle element into a paragraph, like this:</p>
<blockquote>List<ol><li>One</li></ol>Two<ol><li>Three</li></ol></blockquote>
<p>requires the following operation:</p>
<pre data-block-id="9cdde5c0-a1a0-45d9-9409-5709b3f14dd8">{opId: "20@A", action: "updateBlock", updatedId: "9@A", blockType: "p", parents: []}<br/>​</pre>
<h3 data-content-editable-leaf="true">Feedback from Matthew</h3>
<p>Matthew Weidner remarks (email from 26 Feb 2023):</p>
<blockquote>Your design looks reasonable to me, and simpler than a tree-based approach. The downside is the lack of move operations (besides copy-paste), but I imagine that's rarely noticeable.Overall, it's similar to <a data-token-index="1" href="https://quilljs.com/docs/delta/#line-formatting">what Quill does</a> by default: they use "\n" characters as block markers, and store each block's properties as formatting attrs on the "\n". (In Quill's case, they use the trailing \n, but it makes more sense to use the leading \n like in your notes.)There is one minor anomaly:Suppose one user merges blocks A &amp; B (which are in order A &lt; B), while another user concurrently creates a new block C at the end of A.--&gt; Internally, the first user deletes B's anchor, while the second user inserts C's new anchor between A &amp; B. Thus we end up with blocks A &amp; CB. But it seems preferable to get AB &amp; C like in the tree-based approach or <a data-token-index="1" href="https://doi.org/10.1002/cpe.4110">Ignat et al.</a>'s OT.<blockquote>I propose the following representation: every block boundary has a property parents, which contains an array of block types that are parent blocks of this particular block.</blockquote>I think this would work fine. Another option is to assign each list item an explicit "indent level", like Ignat et al.'s "depth", then render it at that indent level (or perhaps `max(this.indentLevel, predecessor.indentLevel + 1)`).<blockquote>(Tables) Then we have a map from (rowId, columnId) pairs to cell content.</blockquote>This is how I would do it as well. One choice I would make is to use a <a data-token-index="1" href="https://collabs.readthedocs.io/en/latest/api/collabs/classes/CLazyMap.html">"lazy" (Riak-style) map</a> instead of an Automerge/Yjs-style map: for every `(rowId, columnId)` pair that has not yet been used, the map implicitly contains a blank cell. That way, if two users concurrently edit a never-before-used cell, their changes are merged in the usual way, instead of overwriting each other.</blockquote>
<h3 data-content-editable-leaf="true">Moving text / reordering things</h3>
<p>One type of operation I've not considered here is moving text from one location to another, or reordering items in a bulleted list, or that sort of thing. It would be great to support that, but it's a really hard problem that nobody seems to have cracked yet. Therefore I propose that for now, text movements are still handled by by deletion and re-insertion of the moved text. This has all sorts of problems, but solving them is a task for another day.</p>
<p>A nice thing about the rich text model discussed here is that it doesn't require solving the text movement problem to provide good behaviour for most interactions supported by rich text editors (apart from cut and paste). However, if we do (separately) manage to figure out text movement for plain text, then we should also be able to plug that algorithm into this rich text model, since the approach proposed here is still based on keeping the textual content of the document in one big, continuous RGA structure.</p>
<h3 data-content-editable-leaf="true">Tables</h3>
<p>A paragraph can be split in two by hitting enter in the middle of it, but this doesn't happen with tables (at least in the rich text editors I've used): if you hit enter in the middle of a table cell, you don't split that cell into two cells — you get a paragraph break within the content of that cell. To move text from one cell to another you need to cut and paste. Adding and removing cells only happens by a user explicitly choosing "add rows" or "add columns" from a menu somewhere; joining adjacent cells is possible but it's a somewhat exotic operation.</p>
<p>For this reason, I suggest we think about the contents of each table cell as essentially a separate document. Within the cell we can have arbitrary block structures (paragraphs, bullet points etc), but there is no need to support splitting and joining cells in the same way as we do for paragraphs. Making each cell independent from the other cells keeps things simple. If we need to perform a formatting operation across cells (e.g. user selects several cells and formats them bold), we can turn that into a separate formatting operation within each selected cell.</p>
<p>In order to support concurrent adding and removing of rows and columns, we can use the following approach. For each table object we maintain two RGA arrays, one containing the list of rows, the other containing a list of columns, giving each row and each column a unique ID. Then we have a map from (rowId, columnId) pairs to cell content. Adding and removing rows/columns is then just an insertion or a deletion on the appropriate RGA array.</p>
<p>This approach would allow for reordering of rows or columns within the same array, simply by reordering the items in the appropriate RGA array. The ID of the row or column being moved would not change, and neither would the content of the cells within it.</p>
<p>It's not immediately obvious how to handle table cells that span several rows or columns. Perhaps they should be identified by a two-dimensional range (startRowId, startColumnId, endRowId, endColumnId)? However, that structure would risk users concurrently creating cells that partially overlap (for example, one cell that spans columns A and B, and another cell that spans columns B and C). Perhaps this is a sufficiently niche edge-case that it's okay to resolve such conflicts by last-write-wins.</p>
