---
author: nolen royalty
cover_image: 'https://eieio.games/images/secure-massively-multiplayer-snake/og.png'
date: '2026-02-26T17:33:19.180Z'
dateFolder: 2026/02/26
description: >-
  snakes.run is a massively multiplayer snake game that uses the Secure Snake
  Home (SSH) protocol. It can render 100M pixels a second.
isBasedOn: 'https://eieio.games/blog/secure-massively-multiplayer-snake/'
link: 'https://eieio.games/blog/secure-massively-multiplayer-snake/'
slug: 2026-02-26-httpseieiogamesblogsecure-massively-multiplayer-snake
tags:
  - fun
  - tech
title: 'snakes.run: rendering 100M pixels a second over ssh'
---
<p>A secure way to play snake online</p>
<p>Feb 25, 2026</p>
<p>I made a massively multiplayer snake game that’s accessible over ssh. Play by running <code>ssh snakes.run</code> in your terminal:</p>
<figure><video controls="" height="1082" playsinline="" width="1472"><source src="https://eieio.games/images/secure-massively-multiplayer-snake/snake-gameplay.mp4" type="video/mp4"/></video><figcaption>come play with me :)</figcaption></figure>
<p>The backend for the game - Snake Session Handler Daemon or <code>sshd</code> - is capable of handling thousands of concurrent players and rendering over a hundred million pixels a second.</p>
<p>You can <a href="https://snake.eieio.games">visit this page</a> to learn more about ssh and its history. Read on to learn about how the game works!</p>
<h2>Challenges</h2>
<p>There were 3 core challenges I ran into building snakes.run.</p>
<ul> <li><strong>Display:</strong> Making snake look nice in the terminal</li> <li><strong>Bandwidth:</strong> My early code used a shocking amount of bandwidth</li> <li><strong>Performance:</strong> Supporting thousands of concurrent players was hard</li> </ul>
<p>But before we jump into those challenges, lemme give you a quick tour of how the game works and how it’s architected.</p>
<h2>Basics</h2>
<p>Everyone connects to the same wrapping playfield. Normal snake rules apply - you eat fruit to grow and die if you hit a snake.</p>
<p><a href="https://snake.eieio.games">ssh</a> is a dumb client; it just receives, decrypts, and displays lines of text sent by the server. So to run our game we render every frame server-side and relay them to our clients.</p>
<p>The game renders frames using <a href="https://github.com/charmbracelet/bubbletea">bubbletea</a> (a TUI framework), which is hooked up to ssh via <a href="https://github.com/charmbracelet/wish/tree/main">wish</a>. I’ve forked both bubbletea and go’s ssh library to reduce bandwidth and improve performance.</p>
<figure><img alt="architecture diagram for snakes.run. Clients are each given their own bubbletea / wish session that talks to a single game server process. Traffic is sent using the SSH (secure snake home) protocol." data-nimg="1" src="https://eieio.games/images/secure-massively-multiplayer-snake/architecture.webp"/><figcaption>architecture diagram for snakes.run. Clients are each given their own bubbletea / wish session that talks to a single game server process. Traffic is sent using the SSH (secure snake home) protocol.</figcaption></figure>
<p>The game server runs at 10 “ticks” a second. Every tick we move and grow players, eat fruit, calculate collisions, and broadcast the new gamestate to clients.</p>
<p>So that’s all pretty simple. How do we draw our snakes?</p>
<h2>Two pixels per character</h2>
<p>My earliest prototype used ascii characters for snakes and fruit. This had a problem - since terminal characters are twice as tall as they are wide, vertical movement felt much faster than horizontal movement:</p>
<p>To fix this, I moved to <a href="https://en.wikipedia.org/wiki/Block_Elements">Unicode Block Elements</a>. Block elements are a (<a href="https://stackoverflow.com/questions/28485545/where-is-upper-one-quarter-block-letter-in-unicode">weirdly incomplete</a>) set of blocky unicode characters like UPPER_HALF_BLOCK (▀), LOWER_HALF_BLOCK (▄), and FULL_BLOCK (█) <a>1</a>.</p>
<p>Rendering a character as a lower block and then as an upper block gives you two “frames” of motion within the same character and looks much smoother.</p>
<p>On top of that, we can get two full pixels of color using foreground and background colors. If we render an upper block with a foreground color of cyan and a background color of red, we get a cyan pixel sitting on top of a red pixel!</p>
<p>This looked much better than what I had before. But it was a bandwidth hog.</p>
<h2>The bandwidth problem</h2>
<p>The first thing I profile when I make a multiplayer game is bandwidth usage. It’s easy to accidentally use too much bandwidth, and it’s typically my one unbounded cost so I want to minimize it.</p>
<pre><code># early profiling data
--------------------------------
frame 1072
bytes 3783800
bytes per frame 3529
--------------------------------
</code></pre>
<p>Testing told me I used ~3,500 bytes for each <em>frame</em> - at 10 FPS, that’s ~35 KB/sec. While a nice T1 line could handle that, it’d easily saturate a 56k modem. And supporting even 1,000 clients would mean pushing 35 <em>megabytes</em> a second - way too much!</p>
<p>To understand my bandwidth usage I looked at <a href="https://github.com/charmbracelet/bubbletea/blob/21eecd586367fd0cd78da6842c48f9c4b1185b6f/standard_renderer.go#L161">how bubbletea rendering worked</a> (ironically, bubbletea made <a href="https://github.com/charmbracelet/bubbletea/releases/tag/v2.0.0">massive improvements to their renderer</a> days before I published this blog <a>2</a>).</p>
<p>The way bubbletea rendering worked at the time was:</p>
<ul> <li>You gave it a string for each frame</li> <li>It split that string into lines</li> <li>If a line was the same as it was on the last frame, it was skipped</li> <li>Otherwise, bubbletea re-sent the entire line to the client</li> </ul>
<p>That looks something like this for a small grid where our snake is moving down. Notice that we delete and re-print 3 entire lines!</p>
<p>Our playfield is (up to) 80x35, and almost every line of it changes on every frame. That means we could send <code>80*35*10 = 28000</code> bytes a second just for the characters on screen. And that’s before accounting for things like colors or SSH overhead!</p>
<p>We can do better.</p>
<h3>Stateful rendering and VT100 sequences</h3>
<p>Terminal applications have a “cursor” that they can move around, just like a text editor. You can tell that cursor “go to line 3, delete everything, then print out this new text” by using <a href="https://vt100.net/docs/vt510-rm/contents.html">VT100 sequences</a>. And you can use it to replace existing characters with new ones, without re-emitting a whole line.</p>
<p>That’s the basis of our custom renderer - we diff each cell and only print changed characters. Here’s the same example from above - but now we just patch the 6 changed cells.</p>
<p>For horizontal movement we can do even better. If your snake is moving to the right, we start by deleting every character on the left edge of the screen and inserting a new one on the right edge. After that, we do our patching (if needed). This automatically moves fruit into the correct position without us even needing to reprint it!</p>
<p>With these changes bandwidth use dropped to around 4.5 KB/sec <a>3</a>. Much improved, but we can still do better.</p>
<details><summary> What about DECSTBM and DECLRMM?</summary><p><a href="https://vt100.net/docs/vt510-rm/DECSTBM.html">DECSTBM</a> and <a href="https://vt100.net/docs/vt510-rm/DECLRMM.html">DECLRMM</a> allow you to set “margins” in the terminal and then “scroll” within those margins. DECSTBM is for vertical margins and DECLRMM is for horizontal ones.</p><p>For example, using DECSTBM you could say “set the top margin to line 5 and the bottom margin to line 10, then scroll up 1” - this “scrolls” the region you’ve described by deleting line 5, shifting everything else in the region up by 1 line, and inserting a new line at line 10.</p><p>DECSTBM doesn’t work because of our unicode half-block shenanigans. We’re squeezing two pixels into each terminal character, and so we want to be able to “scroll” in half-pixels; our scroll needs to turn lower half blocks into upper half blocks when we’re moving vertically. That operation just doesn’t exist.</p><p>DECLRMM might work for us - it is approximately what we’re doing by deleting a character on each line when moving horizontally - but it has extremely poor terminal support so I didn’t want to rely on it.</p></details>
<h3>Stateful 4-bit colors</h3>
<p>The way color works in the terminal is that you echo a sequence like <code>\x1b[38:5:161m</code> to tell the terminal “use color 161 (red) for the foreground.” Then all characters have a foreground color of 161 until you “reset” by sending the sequence <code>\x1b[0m</code>.</p>
<p>Originally, I picked these colors using <a href="https://github.com/charmbracelet/lipgloss">lipgloss</a> - a terminal utility for styling terminal text. You give lipgloss a string and a desired color and it gives you the string COLOR_CODE + YOUR_STRING + RESET.</p>
<p>But that’s a <em>lot</em> of resetting! We can save a bunch of bandwidth by instead tracking the current foreground and background color in our renderer and only emitting a new color escape sequence when our desired color changes. This is an annoying amount of bookkeeping but it substantially cuts down on the amount of escape codes emitted.</p>
<p>As a final tweak, I moved from <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">8 bit ansi colors</a> like <code>\x1b[38:5:161m</code> to <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">4 bit colors</a> like <code>\x1b[31m</code>. This restricts our color range, but it saves something like 6 bytes per color.</p>
<p>These changes, along with a few other small tweaks, took the game down to a nice ~2.5 KB/sec. Not bad. After bandwidth, I started to think about CPU.</p>
<h2>Performance</h2>
<p>I figured the Secure Snake Home community would be excited to have a new server to play on, so I wanted to support at least a thousand concurrent players. But early performance profiling was <em>bad</em>. I was using something like a full core for every 40 users.</p>
<figure><img alt="a flamegraph view of a performance profile. 6.5 seconds of CPU time has been used." data-nimg="1" src="https://eieio.games/images/secure-massively-multiplayer-snake/early-prof.webp"/><figcaption>a flamegraph view of a performance profile. 6.5 seconds of CPU time has been used.</figcaption></figure>
<p>I found one dumb free win (I mistakenly used <a href="https://go.dev/tour/methods/8">value receivers</a> on a utility function called on a large struct thousands of times a frame). But the rest of the speedups I found took more effort.</p>
<h3>Strings and allocations</h3>
<p>25% of my time was spent in <a href="https://github.com/charmbracelet/lipgloss">lipgloss</a> utility functions (lipgloss is a helper library for formatting strings for TUIs).</p>
<p>Lipgloss is handy - you can give it two strings and say “join these together vertically, making sure that they’re both left-aligned” and it’ll do that even if the strings have different widths. It’s built for the terminal, so it knows how to handle ansi escape codes and double-width characters and the like.</p>
<p>But handling that stuff is <em>slow</em>. To calculate a string’s width it can’t call <code>len</code> on the string. Instead it has to <a href="https://github.com/charmbracelet/x/blob/5698041f34d9e1fe09d38b556e203f87f5e38325/ansi/width.go#L80">pass every character through a state machine</a>.</p>
<p>I ripped out almost all of my lipgloss calls and replaced them with hand-rolled functions for concatting and measuring strings. These functions weren’t nearly as general, but that’s fine - they worked for my use case.</p>
<h4>Pre-allocate everything</h4>
<p>After the free win and lipgloss changes, I noticed that ~15% of my CPU time was spent in <code>gcBgMarkWorker</code> - the go garbage collector. That is a <em>lot</em> of time to spend thinking about garbage collection.</p>
<p>The primary cause was all of my hand-rolled string utility functions. While they were faster than lipgloss, they were still generating and throwing away tons of strings on every frame for every player.</p>
<p>To work around this, I started pre-allocating…everything:</p>
<pre><code>var (
	paddingCache                [200]string
	horizontalBarCache          [200]string
	topBorderCache              [200]string
	bottomBorderCache           [200]string
	topLineCache                [400]string
	shutdownBannerCache         [10][400]string // [seconds][width]
	paddedTopBorderCache        [200][200]string
	paddedBottomBorderCache     [200][200]string
	paddedInstructionsCache     [400]string
	paddedInstructionsDeadCache [400]string
	glyphPaddingCache     [200][]tea.StringWithColorPreference
	glyphPlayerCountCache [2000][]tea.StringWithColorPreference
	glyphBlinkCache       [60][]tea.StringWithColorPreference
	glyphSizeCache        [2000][]tea.StringWithColorPreference
	glyphLongestCache     [2000][]tea.StringWithColorPreference
)
</code></pre>
<p>For example, snakes.run has a “banner” that extends across the entire top of your screen. It looks like this:</p>
<pre><code>by eieio.games                      ssh snakes.run
</code></pre>
<p>When the game is about to shut down, the banner is updated to show that:</p>
<pre><code>by eieio.games  SHUTTING DOWN IN 5  ssh snakes.run
</code></pre>
<p>Before string caching, the code would dynamically generate this banner based on your current terminal dimensions on every frame. But that’s wasteful! Now, we pre-compute every banner size (accounting for any amount of shutdown time remaining) ahead of time and slam that pre-computed banner into a byte buffer, skipping the intermediate allocation.</p>
<p>These changes, along with some additional tweaking of bubbletea’s code, reduced time spent in the gc to ~0.5%.</p>
<h3>SSH tweaking</h3>
<p>While continuing to push on performance, I noticed a bizarre pattern - my ssh client sent hundreds of no-op packets along with each move I made. Processing these packets slowed my server down a lot.</p>
<p>Debugging this was interesting enough that I wrote a <a href="https://eieio.games/blog/ssh-sends-100-packets-per-keystroke/">full separate blog</a> about it, but I’ll summarize here.</p>
<p>In 2023, the Secure Snake Home modding collective <a href="https://www.openssh.org/">OpenSSH</a> added <a href="https://undeadly.org/cgi?action=article;sid=20230829051257">keystroke timing obfuscation</a> to their ssh client. The idea is that the <em>timing</em> of your moves gives away information about what the moves are.</p>
<p>While this change is spiritually in line with <a href="https://snake.eieio.games/#history">Tatu Ylonen’s development of ssh to prevent move-sniffing attacks</a>, I figured it wasn’t necessary for us since we’re focused on massively multiplayer play, not competitive play.</p>
<p>Figuring out how to strip it out was a bit of a challenge - I ended up forking go’s crypto library - but it was a <em>huge</em> win. Performance approximately doubled!</p>
<h3>Final tweaks</h3>
<p>The rest of my performance wins were more typical - small reductions in CPU cycles by staring at lots of performance traces.</p>
<p>Here’s a performance profile from today:</p>
<figure><img alt="a flamegraph view of a performance profile. 6.6 seconds of CPU time has been used." data-nimg="1" src="https://eieio.games/images/secure-massively-multiplayer-snake/late-prof.webp"/><figcaption>a flamegraph view of a performance profile. 6.6 seconds of CPU time has been used.</figcaption></figure>
<p>That’s a similar amount of CPU usage as when we started - but I’m running with <em>250</em> users, not <em>10</em>. 25 times faster isn’t bad. With this setup, I’m able to support about 2,500 concurrent users before I start to see any stuttering.</p>
<p>That gives me the math for the title of this post. Each test user had a playfield with ~2,200 characters, and each character contains 2 pixels. The game runs at 10 FPS. <code>2500 * 2200 * 2 * 10</code> is a little over 100 million! Maybe that’s not a fair measurement, but it’s the one I chose.</p>
<h2>Wrapping up</h2>
<p>The ssh modding community has been a joy to watch these last few years. Terminal Products, Inc has managed to <a href="https://www.terminal.shop/">sell coffee over ssh</a> and I’ve heard that the <a href="https://www.openssh.org/">OpenSSH</a> folks have even used it to log into computers remotely!</p>
<p>But I’m really pumped to get Secure Snake Home back to its roots by standing up a way to securely play multiplayer snake online.</p>
<p>I hope you enjoy playing :)</p>
