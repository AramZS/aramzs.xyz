---
author: Dorian Taylor
cover_image: 'https://doriantaylor.com/file/specificity-gradient-still'
date: '2025-07-14T15:37:08.210Z'
dateFolder: 2025/07/14
description: >-
  This is the definitive write-up of the conceptual framework I am calling the
  Specificity Gradient.
isBasedOn: 'https://doriantaylor.com/the-specificity-gradient'
link: 'https://doriantaylor.com/the-specificity-gradient'
slug: 2025-07-14-httpsdoriantaylorcomthe-specificity-gradient
tags:
  - tech
title: The Specificity Gradient
---
<p>The specificity gradient is a term I came up with for <a href="https://doriantaylor.com/shearing-layers-applied-to-the-web">a principle that I have held for many years now</a>, that software is, <a href="https://doriantaylor.com/file/Working%20in%20the%20Post-Industrial%20Era.m4a">as I said on a podcast back in 2010</a>, a very verbose, very precise <em>incantation</em> specifying how an information system ought to behave. What gets written down as software code is the result of a long chain of deliberation, passing through the hands of numerous stakeholders from sharply different disciplines. In the process, the rationale for <em>why</em> the code behaves one way and not another is often lost, or at least misplaced. And herein lies the problem: Code has <em>far</em> too much detail, and is <em>much</em> too preoccupied with its own affairs, to be the authoritative place where business decisions are made.</p>
<p>Indeed, this ratcheting up of technical detail concomitates with an increasing distance from a surface that ordinary people understand, and, I argue, less durable and more volatile with respect to time.</p>
<figure><p class="rw-outer-content"><span>Some content could not be imported from the original document.</span> <a href="https://www.youtube.com/embed/dDE_y7Qri9w">View content ↗ </a></p><figcaption> <p>Interest recently resurfaced in <a href="https://youtu.be/dDE_y7Qri9w">my 2021 video</a> outlining the specificity gradient concept. Note that initially, I had the first category as business <em>goals</em>, but later decided that business ecosystem was more appropriate.</p> </figcaption></figure>
<p>As a conceptual framework, the specificity gradient rests on <a href="https://youtu.be/HTSbtM12IZw">the shearing layer or pace layer concept</a>, which has had some currency in the design community for quite some time. The essence of shearing/​pace layers is that certain concerns operate at certain time scales, and more importantly, the time scales vary enough that anything trying to bridge between them will be ripped apart in the quasi-tectonic <em>shear</em>. So if you’re going to build anything, you build <em>within</em> the respective layers, not across them.</p>
<h2>The Gradient</h2>
<p>The idea of the specificity gradient is to create an unbroken line from the chunkiest thoughts to the most precise ones, adding detail every step of the way. The purpose of this is twofold:</p>
<ol> <li>First, this structure is to encourage describing the system and making decisions at the coarsest possible level, so they don’t have to be relitigated over and over again in finer detail. Moreover, the coarser elements frame and contexutalize the finer ones, such that any more-detailed adaptations can be construed as a delta against the less-detailed ones.</li> <li>Second, coarser-grained elements tend to also be much slower-moving than the finer-grained ones, so we can respond to changes in the environment by pruning (and possibly replacing) a small part of the representation while preserving the rest.</li> </ol>
<p>For software, a reasonable specificity gradient looks like this:</p>
<h3>Business Ecosystem</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Business_ecosystem">business ecosystem</a> is a model of the organization, situated in its immediate geographical, social, political, economic, and legal environment. Its purpose is to model how the organization interfaces with the outside world. Entities in the model can belong to categories like:</p>
<ul> <li>commercial offerings (products, services)</li> <li>materials/​equipment</li> <li>customers</li> <li>suppliers</li> <li>employees</li> <li>shareholders</li> <li>regulators…</li> </ul>
<p>Mission-driven organizations might have <em>constituents</em> rather than <em>customers</em>, and/​or <em>members</em> rather than <em>shareholders</em>; these categories are not necessarily fixed. Likewise, we might model certain relationships with particular entities, such as certain government agencies, or suppliers if they are important enough. Other categories of relationships can be represented by one or more archetypal entities within the category.</p>
<p>Embedded within this ecosystem—indeed, representable by the differences between <em>current</em> and <em>future</em> states of the ecosystem itself—are the organization’s <em>goals</em>. These are the things that the organization wants to accomplish. In the case of a company, this would likely reduce in large part to earn a profit, though other qualitative and quantitative changes will also likely show up.</p>
<p>We can imagine the more detailed tactical objectives turning over every quarter (or quicker), while the core, which would reference institutions, markets, and products, will be considerably more long-lived: markets and institutional milieus can last for centuries, and a product can last at least as long as the business does—so again, years, decades or centuries. My focus here indeed is less on the caprice and mercuriality of everyday business tactics, or even something like quarterly financial targets. The real value of the business ecosystem is to surface and make explicit its own (largely slow-moving) structure, to serve as an anchor for the lower rungs of this model.</p>
<aside> <p>We can actually model the for-profit business as a special case of mission-driven organization, where the mission always reduces to make money. In that way they’re actually kinda simpler.</p> <p>I’ll also remark, for those skittish about the idea of being too candid about business goals, or even committing to writing them down, even in a confidential setting, the big slow stuff is usually going to be pretty obvious to anybody looking. If your organization is important enough, some analyst probably has this information on you already anyway.</p> </aside>
<h3>User Goals</h3>
<p>Every product, software or otherwise, is going to have at least one archetypal user. It is important to recognize that a <em>user</em> may or may not be the same as the <em>customer</em>, but a user nevertheless has goals, and the purpose of the product is to help them achieve those goals, to the extent that they <em>intersect</em> with the business’s goals.</p>
<aside> <p><a href="https://www.amazon.com/dp/0672326140?tag=doriantaylor-20">This is an Alan Cooper-ism.</a> It is a spectacularly valuable insight that nevertheless has to be hammered back into business leaders and designers alike every few years. <a href="https://www.amazon.com/dp/0061252662?tag=doriantaylor-20">Drucker also had a thing about this</a>, although his example was cat food: the cat eats the food but doesn’t buy it, so you have to <em>market</em> the cat food to the <em>owner</em>, but the <em>product</em> will have to be something that the cat demonstrates a preference for (and is free of any unfortunate side effects), or the owner will <em>stop</em> buying it.</p> </aside>
<p>We see here our first jump <em>up</em> in specificity, and <em>down</em> in temporality: a user only (nominally) exists in the context of a product, and so will change as the product changes.</p>
<h3>User Tasks</h3>
<p>A user <em>task</em> is not the same thing as a user <em>goal</em>. A task is a concrete thing that a user has to do to <em>achieve</em> their goal. To the extent that any task must have at least one concrete, specific method, the details of a task may change as say, technology, law, the commercial landscape, or fashion does. A really conspicuous example of this is the arc of computers in the large:</p>
<ul> <li><strong>Inception-1978</strong>: Computers are distant entities, mediated by at least one layer of operator (I’m thinking something like SABRE). Ordinary people don’t interact with them directly at all.</li> <li><strong>1978-1994</strong>: Solipsistic PC era. Computers were quiet (internal chugging notwithstanding), personal things, that you used for personal productivity, that you turned on to use and turned off when you were done. Interoperation was a terrifically <em>manual</em> thing; it had to be supported by phone operators, mailing floppy disks around, and so forth.</li> <li><strong>1994-2007</strong>: Desktop Internet era. With the advent of the Web, it became possible to move, en masse, entire business processes to self-serve, mediated completely by software. But you had to be at your desk (with the modem occupying your phone line on for earlier part of it). Mobile applications, which showed up about halfway through this era, were extremely limited in capability. (Notice these getting shorter?)</li> <li><strong>2007-2010</strong>: Touchscreen smartphone era. At this point we have fast(-ish) and reliable mobile data connections, but more importantly, we have devices we can actually <em>work</em> with, as opposed to the clumsy, janky little things they replaced.</li> <li><strong>2010-2014</strong>: Tablet era. We now have a third screen to contend with, which has most of the affordances of its predecessor, the smartphone, but is bigger and intended to be used while stationary. Syncing your state between devices gains a new level of importance.</li> <li><strong>2014-present</strong>: Everything, everywhere, all at once. Wearables, VR goggles, chatbots, home surveillance, drones, machine learning, DAOs, et cetera. Modalities of interacting with software are mushrooming, and in theory (and often in practice), any number of them could be used in concert.</li> </ul>
<p>This is actually kind of an interesting scenario, because we kind of need to <em>gear down</em> at this level, temporally speaking, since a user is potentially able to complete a task using more than one, or <em>combination</em> of, specific methods. So we need to capture the <em>abstract</em> task, as well as the concrete steps in each medium or channel.</p>
<h3>System Tasks</h3>
<p>The complement of the user task is the <em>system</em> task, which increases once again in specificity and decreases in temporality, because it is going to be bound to the specific procedural, organizational, or technical method of achieving the user’s task. A system task is the sequence of concrete steps the <em>system</em> has to take to support the user in carrying out their task, so that they achieve their goal, so the ultimate customer continues to pay for the product, which contributes to the satisfaction of the business’s goals. Again, we’re going to see a subset of these which are abstract, and are portable across specific technologies and vendor relationships, and a subset which are concrete, and get thrown away when technologies obsolesce or contracts get terminated. As a rule, we do not expect system tasks to survive as long as the longest-lived user tasks.</p>
<h3>System Behaviours</h3>
<p>System behaviours are detailed, concrete, prescriptions and proscriptions about what the system <em>must</em> or <em>must not do</em> in the course of carrying out its tasks, including preventing users from doing things that harm themselves or contravene the business goals. In other words, various user interface safeguards, content moderation policies, and information security concerns live here.</p>
<p>This category is unusual to the extent that it has potentially the <em>widest</em> gamut in temporal sensitivity, eventually spanning several orders of magnitude. However the <em>content</em> is <em>always</em> going to take the form <a href="https://datatracker.ietf.org/doc/html/rfc2119"><strong>MUST</strong> or <strong>MUST NOT</strong>.</a> What is responsible for the wide temporal range is that some of these rules will eventually abstract out into general principles and policies, while others will concern specific implementations of specific steps in specific tasks, which are peculiar to that particular implementation and will only remain relevant as long as the implementation itself does.</p>
<p>This step in the gradient, in addition to being the most detailed description of the system short of source code itself, also has plenty of precedent: one of these rules, at least the most granular variety, more or less maps 1:1 to a bug report or unit test case, which everybody in the industry should be familiar with.</p>
<h3>Code</h3>
<p>Finally, we arrive at the most specific stratum in our gradient of specificity, executable source code. Of course what makes code the most specific is not only the fact that it has to be formally strict and internally consistent in a way that no other layer must, but also that it has to occupy itself with the mundanities of computers <em>themselves</em>—memory management, network connections, storage space, algorithmic efficiency, and the peculiarities of the language in which it is written—all that business which is much too detailed for any of the other layers to bother with.</p>
<p>Code, of course, to the extent that it is getting any attention at all, is continually undergoing changes: parts are being added, removed, moved around. Bugs are getting patched. Third-party dependencies have to be tracked, and any mutations—which on the whole are frequent—need to be compensated for. Frameworks, languages, even architectural styles, go in and out of fashion. <em>Vanishingly</em> few pieces of software (notably TeX) refine towards a gem-like state of stability.</p>
<p>In fact, I’m inclined to say that code is old, it’s likely pathological: it exhibits <em>unspecified</em> behaviour, i.e., it does things and nobody knows how, or often even precisely <em>what</em>, so they’re afraid to touch it, because the business depends on it. Part of the idea behind the specificity gradient is to prevent getting into this position.</p>
<h2>Remarks About Code</h2>
<p>Here is where I say something mildly controversial: I think <em>way</em> too much value is placed on code. Sure, you need <em>an</em> implementation, or you don’t have a product. But what seems to happen so often is that all the materials that served as the basis for all the decisions that made the product <em>possible</em>, are left to rot. This, I believe, is a mistake.</p>
<p>The code, on the other hand, is elevated to sacrosanct. The attitude toward code is don’t touch it if you don’t have to (which is silly, because you almost always have to). I mean, I <em>get</em> it—code that runs correctly, and efficiently, and doesn’t break, is a hard-won battle. Plus, it’s the thing that makes the money. So don’t screw with it. Except we screw with it all the time! (Under controlled circumstances, mind you.)</p>
<p>Suppose, for a moment, that the language the code was written in, or maybe some major dependency, suddenly became inviable. Plausible scenarios for this include some irreconcilable security flaw getting discovered, or some change in licensing or event in the legal domain. Or let’s just say that somehow your codebase just gets deleted. How screwed would you be?</p>
<p>The answer, I’m guessing, is probably totally, completely screwed, because the code is the only place where most of the system’s description is embodied. Part of the motivation for a specificity gradient would be to capture as much of this information as possible, somewhere <em>other</em> than the code.</p>
<aside> <p>As somebody who writes a lot of libraries in a number of different languages, I have definitely implemented many instances of the same thing in more than one language. I have found that while it may have been hard to make the first one, subsequent implementations (barring any catastrophic third-party defect), while not the most <em>interesting</em>, is about as straightforward a programming task as you can get.</p> </aside>
<p>If we treated code as what it <em>is</em>, namely, the substance at the very end of a long, multi-layered gradient of increasing specificity, then I don’t think we would need to be so precious about it. Indeed, migrating (or expanding) platforms, frameworks, and even languages, happens a lot more frequently than we’d like to admit. I’m saying that this need not be as expensive and/​or risky a proposition as it currently is, if we had an infrastructure like the one I just described. I’m talking about relieving code of the burden of being the residual source of knowledge about the system. It’s a bad place for that, anyway.</p>
<h2>There Is Plenty of Precedent</h2>
<p>Not only do the origins of this thinking—Frank Duffy’s shearing layers and Stewart Brand’s pace layers—represent, but programmers themselves already have pieces of this puzzle: behaviour-driven development, literate programming, design patterns, even plain-old bug reporting. The military strategy, management strategy, operations research, and systems people have models out the yin-yang, and let’s not forget the UX people, who fill in the rest. What’s missing is an unbroken path that takes you from one end of the edifice to the other.</p>
<h2>This Is a Structure, Not a Procedure</h2>
<p>I want to make it clear that the specificity gradient is <em>not</em> an instruction manual, in the sense that first you do the business ecosystem, then you do user goals, and so on—even though that would be a sensible start. For one, the gradient kind of zippers together a bunch of different disciplines, by system tasks at the latest, but prior to that, the disciplines are each going to be doing their own thing.</p>
<p>Note as well that nowhere in this description do I say the word <em>feature</em>.</p>
<h2>How I Ultimately See This Play Out</h2>
<p>A website, of course. But not just any website: this would be something that (naturally) was walled off from the outside world by default (that is, an intranet), and possess unprecedented power as a <em>solvent</em> of documents and data sources. Its job would be to make everything maximally <em>addressable</em>: jack into every API, decompose every document, suffuse every database.</p>
<p>This website would not have pages per se; rather everything navigable—that is to say, <em>everything</em>—would be a piece of structured data that could be transformed and composed into more complex structures. This structuring and composition capability should be available to anybody involved, and easy enough (with no irreversible consequences) for any relevant person in the organization with any background to be trained to do.</p>
<aside> <p>Well over a decade ago, we had these things called structured wikis, which is about as close to what I’m suggesting as one has ever gotten. Structured wikis never went anywhere, I suspect in part because of their horseless carriage characteristic: the goal of a wiki is to be <em>quick</em> (to implement as well as edit—it’s in the name, after all), which I see as table stakes—more effort needs to be put into the <em>structure</em> part. Something like <a href="https://roamresearch.com/">Roam</a> might be a little closer, but even Roam lacks the structure I’d be looking for.</p> </aside>
<p>It is a safe bet that the overwhelming majority of this forensic content—to the extent that it exists—is going to (at least initially) come from conventional office file formats (Word, Excel, Powerpoint, and their Apple and Google successors). Other elements will be addressable through database or API adapters. Some of the content will inevitably be irretrievable, be it legitimately lost, in some archaic file format, or perished due to a canceled SaaS contract. What remains will likely have to be hand-transcribed.</p>
<p>Eventually, documents in general will recede in importance as <em>origins</em> of information and will instead become targets for <em>projecting</em> information. The native form of the content will eventually make its way toward the shape of a dense hypermedia network: small pieces, loosely joined.</p>
<h2>In the Meantime</h2>
<p>What I just described in the last section is what I would ultimately like to see, and am working towards in my own practice. In the interim I am confident that the <em>spirit</em> of the specificity gradient can be applied to existing tooling, assuming a modicum of discipline.</p>
<p>If you or your team is considering moving in this direction, <a href="javascript:sendMail('doriantaylor.com','website','Specificity%20gradient')">this is something we can discuss</a>.</p>
