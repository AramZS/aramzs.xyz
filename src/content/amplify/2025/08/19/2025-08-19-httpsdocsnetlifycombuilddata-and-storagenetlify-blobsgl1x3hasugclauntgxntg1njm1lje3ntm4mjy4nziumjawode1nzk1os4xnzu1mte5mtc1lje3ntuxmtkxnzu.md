---
author: Netlify Docs
cover_image: 'https://docs.netlify.com/images/netlify-docs-hero-card.png/?v=1'
date: '2025-08-19T14:47:43.751Z'
dateFolder: 2025/08/19
description: >-
  Store and retrieve unstructured data. Use blob storage as a simple key/value
  store or basic database.
isBasedOn: >-
  https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.
link: >-
  https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.
slug: >-
  2025-08-19-httpsdocsnetlifycombuilddata-and-storagenetlify-blobsgl1x3hasugclauntgxntg1njm1lje3ntm4mjy4nziumjawode1nzk1os4xnzu1mte5mtc1lje3ntuxmtkxnzu
tags:
  - code
title: Netlify Blobs UI
---
<p>With Netlify Blobs, you can store and retrieve <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">blobs</a> and unstructured data. You can also use this feature as a simple key/value store or basic database.</p>
<p>Netlify Blobs is a highly-available data store optimized for frequent reads and infrequent writes.</p>
<p>For maximum flexibility, it offers a <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/#consistency">configurable consistency model</a>. If multiple write calls to the same key are issued, the last write wins.</p>
<p>We automatically handle provisioning, configuration, and access control for you. This integrated zero-configuration solution helps you focus on building business value in your project rather than toil on setting up and scaling a separate blob storage solution.</p>
<p>Each blob belongs to a single site. A site can have multiple namespaces for blobs. We call these <em>stores</em>. This allows you to, for example, have the key <code>my-key</code> exist as an object in a store for <code>file-uploads</code> and separately as an object in a store for <code>json-uploads</code> with different data. Every blob must be associated with a store, even if a site is not using multiple namespaces.</p>
<p>You can perform CRUD operations for Netlify Blobs from the following Netlify features:</p>
<p>You can also:</p>
<ul> <li>write to deploy-specific stores using <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#file-based-uploads">file-based uploads</a></li> <li>browse and download blobs in the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#netlify-blobs-ui">Netlify Blobs UI</a></li> </ul>
<p>Netlify Blobs is a platform primitive that developers and frameworks can use as a building block for many different purposes. Here are a few <a href="https://www.netlify.com/blog/introducing-netlify-blobs-beta/">examples of powerful patterns</a> that you can use:</p>
<ul> <li><strong>Data store for functions.</strong> With <a href="https://docs.netlify.com/build/functions/background-functions">Background Functions</a>, you can trigger asynchronous serverless workflows for long-running operations like generating a site map, processing media assets, or sending emails in bulk. You can then use Netlify Blobs to persist the output of those computations.</li> <li><strong>Processing user uploads.</strong> If your application takes user submissions, like reviews on a product page or image files for a gallery, Netlify Blobs can store that data. When paired with Functions or Edge Functions, you can create an endpoint to receive an upload, validate the contents, and persist the validated data.</li> </ul>
<p>For more advanced use cases — such as those that require complex queries, concurrency control, or a relational data model — explore our <a href="https://www.netlify.com/integrations/database-and-backend/">integrations with the best-in-class database vendors</a>.</p>
<p>To use the Netlify Blobs API, first install the <code>@netlify/blobs</code> module using the <a href="https://docs.netlify.com/build/configure-builds/manage-dependencies#javascript-dependencies">package manager of your choice</a>:</p>
<figure><figcaption>Terminal window</figcaption><pre data-language="bash"><code>npm install @netlify/blobs</code></pre></figure>
<p>Then use the below methods in your functions, edge functions, or build plugins.</p>
<p>Opens a site-wide store for reading and writing blobs. Data added to that store will be persisted on new deploys, available on all <a href="https://docs.netlify.com/deploy/deploy-overview#branches-and-deploys">deploy contexts</a> and accessible from from <a href="https://docs.netlify.com/build/functions/overview">Functions</a>, <a href="https://docs.netlify.com/build/edge-functions/overview">Edge Functions</a> and <a href="https://docs.netlify.com/extend/install-and-use/build-plugins">Build Plugins</a>.</p>
<figure><pre data-language="js"><code>const store = getStore(name, { siteID, token })</code></pre></figure>
<aside> <p><figure></figure></p> <p>Your <code>SiteID</code> appears as the Project ID in the Netlify app UI at <code>app.netlify.com</code>. To find this ID in the Netlify UI, go to <a href="https://app.netlify.com/projects/aramzsxyz/configuration/general#project-information"><strong>Project configuration &gt; General &gt; Project information</strong></a>, and copy the value for <strong>Project ID</strong>.</p> </aside>
<ul> <li><strong><code>name</code>:</strong> the name of the store; this can be any string that adheres to the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/#requirements-and-limitations">store naming requirements</a></li> <li><strong><code>siteID</code></strong> (optional)<strong>:</strong> the ID of the Netlify site associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins. You can also set the <code>siteID</code> to the ID of another site you own to access its blobs via the <code>getStore</code> method.</li> </ul>
<aside> <p><figure></figure></p> <p>Your <code>SiteID</code> appears as the Project ID in the Netlify app UI at <code>app.netlify.com</code>. To find this ID in the Netlify UI, go to <a href="https://app.netlify.com/projects/aramzsxyz/configuration/general#project-information"><strong>Project configuration &gt; General &gt; Project information</strong></a>, and copy the value for <strong>Project ID</strong>.</p> </aside>
<ul> <li><strong><code>token</code></strong> (optional)<strong>:</strong> a <a href="https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli#obtain-a-token-in-the-netlify-ui">Netlify Personal Access Token</a> that grants access to Blobs on the given site; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins</li> </ul>
<aside> <p><figure></figure></p> <p>To find your Netlify site ID (also called Project ID in the Netlify UI), go to <a href="https://app.netlify.com/projects/aramzsxyz/configuration/general#project-information"><strong>Project configuration &gt; General &gt; Project information</strong></a>, and copy the value for <strong>Project ID</strong></p> </aside>
<p>An instance of a store on which you can <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#get">get</a>, <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#set">set</a> or <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#delete">delete</a> blobs.</p>
<p>Opens a <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#deploy-specific-stores">deploy-specific store</a> for reading and writing blobs. Data added to that store will be scoped to a specific deploy, available on all <a href="https://docs.netlify.com/deploy/deploy-overview#branches-and-deploys">deploy contexts</a> and accessible from from <a href="https://docs.netlify.com/build/functions/overview">Functions</a>, <a href="https://docs.netlify.com/build/edge-functions/overview">Edge Functions</a> and <a href="https://docs.netlify.com/extend/install-and-use/build-plugins">Build Plugins</a>.</p>
<figure><pre data-language="js"><code>const store = getDeployStore(name, { deployID, region, siteID, token })</code></pre></figure>
<aside> <p><figure></figure></p> <p>Your <code>SiteID</code> appears as the Project ID in the Netlify app UI at <code>app.netlify.com</code>. To find this ID in the Netlify UI, go to <a href="https://app.netlify.com/projects/aramzsxyz/configuration/general#project-information"><strong>Project configuration &gt; General &gt; Project information</strong></a>, and copy the value for <strong>Project ID</strong>.</p> </aside>
<ul> <li><strong><code>name</code>:</strong> the name of the store; this can be any string that adheres to the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/#requirements-and-limitations">store naming requirements</a></li> <li><strong><code>deployID</code></strong> (optional)<strong>:</strong> the ID of the Netlify deploy associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins</li> <li><strong><code>region</code></strong> (optional)<strong>:</strong> the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#regions">region</a> associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins</li> <li><strong><code>siteID</code></strong> (optional)<strong>:</strong> the ID of the Netlify site associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins.</li> </ul>
<aside> <p><figure></figure></p> <p>Your <code>SiteID</code> appears as the Project ID in the Netlify app UI at <code>app.netlify.com</code>. To find this ID in the Netlify UI, go to <a href="https://app.netlify.com/projects/aramzsxyz/configuration/general#project-information"><strong>Project configuration &gt; General &gt; Project information</strong></a>, and copy the value for <strong>Project ID</strong>.</p> </aside>
<ul> <li><strong><code>token</code></strong> (optional)<strong>:</strong> a <a href="https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli#obtain-a-token-in-the-netlify-ui">Netlify Personal Access Token</a> that grants access to Blobs on the given site; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins</li> </ul>
<p>An instance of a store on which you can <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#get">get</a>, <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#set">set</a> or <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#delete">delete</a> blobs.</p>
<p>Creates an object with the given key and value. If an entry with the given key already exists, its value is overwritten.</p>
<figure><pre data-language="js"><code>await store.set(key, value, { metadata, onlyIfMatch, onlyIfNew })</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> <li><strong><code>metadata</code></strong> (optional)<strong>:</strong> a JSON object with arbitrary metadata to attach to the object</li> <li><strong><code>onlyIfMatch</code></strong> (optional)<strong>:</strong> when set, the write will only succeed if the entry exists and has an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a> matching this value</li> <li><strong><code>onlyIfNew</code></strong> (optional)<strong>:</strong> when set, the write will only succeed if the entry does not exist</li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>modified</code></strong> (boolean): Whether the operation has actually generated a new entry</li> <li><strong><code>etag</code></strong> (string): The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a> of the entry, if the operation has generated a new entry; if not, this property will be omitted</li> </ul>
<p>This example shows how you might use Netlify Blobs to persist user-generated uploads. For a more in-depth explanation, refer to <a href="https://developers.netlify.com/guides/user-generated-uploads-with-netlify-blobs/">this guide</a>.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const form = await req.formData();const file = form.get("file") as File;const uploads = getStore("file-uploads");await uploads.set(key, file, {metadata: { country: context.geo.country.name }</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions";export default async (req: Request, context: Context) =&gt; {const form = await req.formData();const file = form.get("file") as File;const uploads = getStore("file-uploads");await uploads.set(key, file, {metadata: { country: context.geo.country.name }</code></pre></figure>
<figure><pre data-language="js"><code>import { readFile } from "node:fs/promises";export const onPostBuild = async () =&gt; {const file = await readFile("some-file.txt", "utf8");const uploads = getStore("file-uploads");await uploads.set(key, file, {</code></pre></figure>
<p>The example below shows how you can use the <code>onlyIfMatch</code> and <code>onlyIfNew</code> properties to do atomic, conditional writes.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const emails = getStore("emails");const { modified } = await emails.set(return new Response("Email already exists", { status: 400 });</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const emails = getStore("emails");const { data, etag } = myLocalCache.get("jane@netlify.com")const { modified } = await emails.set(if (!modified) {</code></pre></figure>
<p>Convenience method for creating a JSON-serialized object. If an entry with the given key already exists, its value is overwritten.</p>
<figure><pre data-language="js"><code>setJSON(key, value, { metadata, onlyIfMatch, onlyIfNew })</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> <li><strong><code>metadata</code></strong> (optional)<strong>:</strong> a JSON object with arbitrary metadata to attach to the object</li> <li><strong><code>onlyIfMatch</code></strong> (optional)<strong>:</strong> when set, the write will only succeed if the entry exists and has an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a> matching this value</li> <li><strong><code>onlyIfNew</code></strong> (optional)<strong>:</strong> when set, the write will only succeed if the entry does not exist</li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>modified</code></strong> (boolean): Whether the operation has actually generated a new entry</li> <li><strong><code>etag</code></strong> (string): The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a> of the entry, if the operation has generated a new entry; if not, this property will be omitted</li> </ul>
<p>This example shows how you might use Netlify Blobs to persist user-generated data.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const uploads = getStore("json-uploads");metadata: { country: context.geo.country.name }</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions";export default async (req: Request, context: Context) =&gt; {const uploads = getStore("json-uploads");metadata: { country: context.geo.country.name }</code></pre></figure>
<figure><pre data-language="js"><code>import { readFile } from "node:fs/promises";export const onPostBuild = async () =&gt; {const file = await readFile("some-file.txt", "utf8");const uploads = getStore("json-uploads");</code></pre></figure>
<p>Retrieves an object with the given key.</p>
<figure><pre data-language="js"><code>await store.get(key, { consistency, type })</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> <li><strong><code>consistency</code></strong> (optional)<strong>:</strong> a string representing the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#consistency">consistency model</a> for the operation</li> <li><strong><code>type</code></strong> (optional)<strong>:</strong> the format in which the object should be returned — the default format is a string but you can specify one of the following values instead: <ul> <li><strong><code>json</code>:</strong> parses the entry as JSON and returns the resulting object</li> <li><strong><code>text</code>:</strong> default, returns the entry as a string of plain text</li> </ul> </li> </ul>
<p>A <code>Promise</code> that resolves with the blob in the format specified by <code>type</code>: <code>ArrayBuffer</code>, <code>Blob</code>, <code>Object</code>, <code>ReadableStream</code> or a string.</p>
<p>If an object with the given key is not found, a <code>Promise</code> that resolves with <code>null</code> is returned.</p>
<p>This example shows how you might read user-generated data that has been previously uploaded to Netlify Blobs.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const entry = await uploads.get(key);if (entry === null) {return new Response(`Could not find entry with key ${key}`, {</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions";export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const entry = await uploads.get(key);if (entry === null) {return new Response(`Could not find entry with key ${key}`, {</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const uploads = getDeployStore("file-uploads");const entry = await uploads.get("my-key");console.log("Could not find entry");</code></pre></figure>
<p>Retrieves an object along with its metadata.</p>
<p>This method is useful to check if a blob exists without actually retrieving it and having to download a potentially large blob over the network.</p>
<figure><pre data-language="js"><code>await store.getWithMetadata(key, { consistency, etag, type })</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> <li><strong><code>consistency</code></strong> (optional)<strong>:</strong> a string representing the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#consistency">consistency model</a> for the operation</li> <li><strong><code>etag</code></strong> (optional)<strong>:</strong> an opaque quoted string, possibly prefixed by a weakness indicator, representing the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><code>ETag</code> value</a> of any version of this blob you may have cached — this allows you to do <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests">conditional requests</a></li> <li><strong><code>type</code></strong> (optional)<strong>:</strong> the format in which the object should be returned — the default format is a string but you can specify one of the following values instead: <ul> <li><strong><code>json</code>:</strong> parses the entry as JSON and returns the resulting object</li> <li><strong><code>text</code>:</strong> default, returns the entry as a string of plain text</li> </ul> </li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>data</code>:</strong> the blob contents in the format specified by the <code>type</code> parameter, or <code>null</code> if the <code>etag</code> property is the same as the <code>etag</code> parameter (meaning the cached object is still fresh)</li> <li><strong><code>etag</code>:</strong> an opaque quoted string, possibly prefixed by a weakness indicator, representing the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><code>ETag</code> value</a> of the object</li> <li><strong><code>metadata</code>:</strong> object with arbitrary metadata</li> </ul>
<p>If an object with the given key is not found, a <code>Promise</code> that resolves with <code>null</code> is returned.</p>
<p>This example shows how you might read metadata from user-generated submissions that have been previously uploaded to Netlify Blobs.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const { data, metadata } = await uploads.getWithMetadata(key);if (entry === null) {return new Response(`Could not find entry with key ${key}`, {return new Response(entry, { headers: { "X-Country": metadata.country } });</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const { data, metadata } = await uploads.getWithMetadata(key);if (entry === null) {return new Response(`Could not find entry with key ${key}`, {return new Response(entry, { headers: { "X-Country": metadata.country } });</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const uploads = getDeployStore("file-uploads");const { data, metadata } = await uploads.getWithMetadata("my-key");console.log("Could not find entry");console.log("Data:", data);console.log("Country:", metadata.country);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const { data, etag } = await uploads.getWithMetadata("my-key", {writeInMockCache("my-key", data, etag);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const { data, etag } = await uploads.getWithMetadata("my-key", {writeInMockCache("my-key", data, etag);</code></pre></figure>
<p>You can use object metadata to create client-side expiration logic. To delete blobs you consider expired, do the following:</p>
<ol> <li><a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#set"><code>set</code> your objects with metadata</a> that you can base the expiration logic on, such as a timestamp</li> <li><code>getWithMetadata</code> to check if an object is expired</li> <li><a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#delete"><code>delete</code></a> the expired object</li> </ol>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const key = "my-key";await uploads.set(key, await req.text(), {if (entry === null) {const { expiration } = entry.metadata;if (expiration &amp;&amp; expiration &lt; Date.now()) {await uploads.delete(key);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const key = "my-key";await uploads.set(key, await req.text(), {if (entry === null) {const { expiration } = entry.metadata;if (expiration &amp;&amp; expiration &lt; Date.now()) {await uploads.delete(key);</code></pre></figure>
<p>Retrieves the metadata for an object, if the object exists.</p>
<p>This method is useful to check if a blob exists without actually retrieving it and having to download a potentially large blob over the network.</p>
<figure><pre data-language="js"><code>await store.getMetadata(key, { consistency, etag, type })</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> <li><strong><code>consistency</code></strong> (optional)<strong>:</strong> a string representing the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#consistency">consistency model</a> for the operation</li> <li><strong><code>etag</code></strong> (optional)<strong>:</strong> an opaque quoted string, possibly prefixed by a weakness indicator, representing the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><code>ETag</code> value</a> of any version of this blob you may have cached — this allows you to do <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests">conditional requests</a></li> <li><strong><code>type</code></strong> (optional)<strong>:</strong> the format in which the object should be returned — the default format is a string but you can specify one of the following values instead: <ul> <li><strong><code>json</code>:</strong> parses the entry as JSON and returns the resulting object</li> <li><strong><code>text</code>:</strong> default, returns the entry as a string of plain text</li> </ul> </li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>metadata</code>:</strong> object with arbitrary metadata</li> <li><strong><code>etag</code>:</strong> an opaque quoted string, possibly prefixed by a weakness indicator, representing the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><code>ETag</code> value</a> of the object</li> </ul>
<p>If an object with the given key is not found, a <code>Promise</code> that resolves with <code>null</code> is returned.</p>
<p>This example shows how you might read metadata from user-generated submissions that have been previously uploaded to Netlify Blobs.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const entry = await uploads.getMetadata(key);if (entry === null) {</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");const entry = await uploads.getMetadata(key);if (entry === null) {</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const uploads = getDeployStore("file-uploads");const entry = await uploads.getMetadata("my-key");console.log(entry.etag, entry.metadata);</code></pre></figure>
<p>Returns a list of blobs in a given store.</p>
<figure><pre data-language="js"><code>await store.list({ directories, paginate, prefix })</code></pre></figure>
<ul> <li><strong><code>directories</code></strong> (optional)<strong>:</strong> a boolean that indicates whether keys with the <code>/</code> character should be treated as directories, returning a list of sub-directories at a given level rather than all the keys inside them</li> <li><strong><code>paginate</code></strong> (optional)<strong>:</strong> a boolean that specifies whether you want to <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#manual-pagination">handle pagination manually</a> — by default, it is handled automatically</li> <li><strong><code>prefix</code></strong> (optional)<strong>:</strong> a string for filtering down the entries; when specified, only the entries whose key starts with that prefix are returned</li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>blobs</code>:</strong> an array of blobs that match the query parameters, shown as objects with <code>etag</code> and <code>key</code> properties, which represent an object’s <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><code>ETag</code> value</a> and key, respectively</li> <li><strong><code>directories</code>:</strong> an array of strings representing any directories matching the query parameters</li> </ul>
<p>This example shows how you might list all blobs in a given store, logging the key and etag of each entry.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const { blobs } = await uploads.list();// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]return new Response(`Found ${blobs.length} blobs`);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore("file-uploads");const { blobs } = await uploads.list();// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]return new Response(`Found ${blobs.length} blobs`);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const uploads = getDeployStore("file-uploads");const { blobs } = await uploads.list();// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]</code></pre></figure>
<p>Optionally, you can group blobs together under a common prefix and then browse them hierarchically when listing a store. This is similar to grouping files in a directory. To browse hierarchically, do the following:</p>
<ol> <li>Group keys hierarchically with the <code>/</code> character in your key names.</li> <li>List entries hierarchically with the <code>directories</code> parameter.</li> <li>Drill down into a specific directory with the <code>prefix</code> parameter.</li> </ol>
<p>Take the following set of keys as an example:</p>
<p>By default, <code>list</code> will return all five keys.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs } = await animals.list();return new Response(`Found ${blobs.length} blobs`);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs } = await animals.list();return new Response(`Found ${blobs.length} blobs`);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const animals = getDeployStore("animals");const { blobs } = await animals.list();</code></pre></figure>
<p>To list entries hierarchically, set the <code>directories</code> parameter to <code>true</code>.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs, directories } = await animals.list({ directories: true });return new Response(`Found ${blobs.length} blobs and ${directories.length} directories`);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs, directories } = await animals.list({ directories: true });return new Response(`Found ${blobs.length} blobs and ${directories.length} directories`);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const animals = getDeployStore("animals");const { blobs, directories } = await animals.list({ directories: true });</code></pre></figure>
<p>To drill down into a directory and get a list of its items, set the <code>prefix</code> parameter to the directory name.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs, directories } = await animals.list({return new Response(`Found ${blobs.length} blobs and ${directories.length} directories`);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const animals = getStore("animals");const { blobs, directories } = await animals.list({return new Response(`Found ${blobs.length} blobs and ${directories.length} directories`);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const animals = getDeployStore("animals");const { blobs, directories } = await animals.list({</code></pre></figure>
<p>Note that the prefix includes a trailing slash. This ensures that only entries under the <code>cats</code> directory are returned. Without a trailing slash, other keys like <code>catsuit</code> would also be returned.</p>
<p>For performance reasons, the server groups results into pages of up to 1,000 entries. By default, the <code>list</code> method automatically retrieves all pages, meaning you’ll always get the full list of results.</p>
<p>To handle pagination manually, set the <code>paginate</code> parameter to <code>true</code>. This makes <code>list</code> return an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator"><code>AsyncIterator</code></a>, which lets you take full control over the pagination process. This means you can fetch only the data you need when you need it.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const store = getStore("animals");for await (const entry of store.list({ paginate: true })) {blobCount += entry.blobs.length;console.log(entry.blobs);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const store = getStore("animals");for await (const entry of store.list({ paginate: true })) {blobCount += entry.blobs.length;console.log(entry.blobs);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const store = getDeployStore("animals");for await (const entry of store.list({ paginate: true })) {blobCount += entry.blobs.length;console.log(entry.blobs);console.log(`Found ${blobCount} blobs`);</code></pre></figure>
<p>Returns a list of stores for a site. Does not include <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/#deploy-specific-stores">deploy-specific stores</a>.</p>
<figure><pre data-language="js"><code>await listStores({ paginate })</code></pre></figure>
<ul> <li><strong><code>paginate</code></strong> (optional)<strong>:</strong> a boolean that specifies whether you want to <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#manual-store-pagination">handle pagination manually</a> — by default, it is handled automatically</li> </ul>
<p>A <code>Promise</code> that resolves with an object containing the following properties:</p>
<ul> <li><strong><code>stores</code>:</strong> an array of strings representing any stores matching the query parameters</li> </ul>
<p>This example shows how you might list all stores for a given site.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const { stores } = await listStores();return new Response(`Found ${stores.length} stores`);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const { stores } = await listStores();return new Response(`Found ${stores.length} stores`);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const { stores } = await listStores();</code></pre></figure>
<p>For performance reasons, the server groups results into pages of up to 1,000 stores. By default, the <code>listStores</code> method automatically retrieves all pages, meaning you’ll always get the full list of results.</p>
<p>To handle pagination manually, set the <code>paginate</code> parameter to <code>true</code>. This makes <code>listStores</code> return an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator"><code>AsyncIterator</code></a>, which lets you take full control over the pagination process. This means you can fetch only the data you need when you need it.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {for await (const entry of listStores({ paginate: true })) {storeCount += entry.stores.length;console.log(entry.stores);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {for await (const entry of listStores({ paginate: true })) {storeCount += entry.stores.length;console.log(entry.stores);</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {storeCount += entry.stores.length;console.log(entry.stores);console.log(`Found ${storeCount} stores`);</code></pre></figure>
<p>Deletes an object with the given key, if one exists.</p>
<figure><pre data-language="js"><code>await store.delete(key)</code></pre></figure>
<ul> <li><strong><code>key</code>:</strong> a string representing the object key</li> </ul>
<p>A <code>Promise</code> that resolves with <code>undefined</code>.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");await uploads.delete(key);</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions"&gt;export default async (req: Request, context: Context) =&gt; {const { key } = context.params;const uploads = getStore("file-uploads");await uploads.delete(key);</code></pre></figure>
<figure><pre data-language="js"><code>import { getDeployStore } from "@netlify/blobs"&gt;export const onPostBuild = async () =&gt; {const uploads = getDeployStore("file-uploads");await uploads.delete("my-key");console.log("Blob has been deleted");</code></pre></figure>
<p>With file-based uploads, you can write blobs to <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#deploy-specific-stores">deploy-specific stores</a> after the build completes and before the deploy starts. This can be useful for authors of frameworks and other tools integrating with Netlify as it does not require a build plugin.</p>
<p>To make file-based uploads, place blob files in <code>.netlify/blobs/deploy</code> in your site’s <a href="https://docs.netlify.com/build/configure-builds/overview#definitions">base directory</a>. Netlify uploads these files to blob storage maintaining their directory structure. Here is an example file tree:</p>
<p>This uploads the following blobs:</p>
<ul> <li><code>dogs/good-boy.jpg</code></li> <li><code>cat.jpg</code></li> <li><code>mouse.jpg</code></li> </ul>
<p>To attach metadata to a blob, include a JSON file that prefixes the corresponding blob filename with <code>$</code> and has a <code>.json</code> extension. For example:</p>
<p>This uploads the following blobs:</p>
<ul> <li><code>dogs/good-boy.jpg</code> with the metadata from <code>dogs/$good-boy.jpg.json</code></li> <li><code>cat.jpg</code> without metadata</li> <li><code>mouse.jpg</code> with the metadata from <code>$mouse.jpg.json</code></li> </ul>
<p>Metadata files must contain valid JSON or the deploy will fail. Here’s an example of valid JSON metadata:</p>
<p>By default, the Netlify Blobs API uses an <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> model, where data is stored in a single region and cached at the edge for fast access across the globe. When a blob is added, it becomes globally available immediately. Updates and deletions are guaranteed to be propagated to all edge locations within 60 seconds.</p>
<p>You can configure this behavior and opt-in to strong consistency with the <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#netlify-blobs-api">Netlify Blobs API</a>, either for an entire store or for individual read operations. <a href="https://cli.netlify.com/commands/blobs/">Netlify CLI</a> always uses strong consistency.</p>
<p>Choosing the right consistency model depends on your use case and each option comes with tradeoffs:</p>
<ul> <li>if it’s important for your application that updates and deletions become immediately available to all readers, you should consider using <code>strong</code> consistency, which comes with the cost of slower reads</li> <li>if that is not a hard requirement and you’re optimizing for fast reads, you should consider using <code>eventual</code> consistency</li> </ul>
<figure><pre data-language="ts"><code>import { getStore } from "@netlify/blobs";import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const store = getStore({ name: "animals", consistency: "strong" });await store.set("dog", "🐶");const dog = await store.get("dog");</code></pre></figure>
<figure><pre data-language="ts"><code>import { getStore } from "@netlify/blobs";import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const store = getStore("animals");await store.set("dog", "🐶");const dog1 = await store.get("dog");const dog2 = await store.get("dog", { consistency: "strong" });</code></pre></figure>
<p>In addition to using the Netlify Blobs API to <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#list">list</a> and <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#get">get</a> blobs, you can use the Netlify UI to browse and download blobs.</p>
<p>To explore and retrieve your site’s blobs:</p>
<ol> <li> <p>In the Netlify UI, go to the <a href="https://app.netlify.com/projects/aramzsxyz/blobs"><strong>Blobs</strong></a> page for your project.</p> </li> <li> <p>If your site has more than one store, select the store of interest.</p> </li> <li> <p>Then, drill into directories to explore the blobs in the store or <strong>Download</strong> an individual blob to examine it.</p> </li> </ol>
<p>You can store sensitive data with Netlify Blobs. To keep your data secure, we encrypt your blobs at rest and in transit.</p>
<p>Your blobs can only be accessed through your own site. You are responsible for making sure the code you use to access your blobs doesn’t allow data to leak. We recommend that you consider the following best practices:</p>
<ul> <li>Do not allow incoming requests for arbitrary keys if you have sensitive data. Treat user input as unsafe and scope your keys with something that callers cannot tamper with.</li> <li>Review the code of any <a href="https://docs.netlify.com/extend/install-and-use/build-plugins#file-based-installation">build plugin you install from the npm public registry</a> to make sure it doesn’t have malicious blob interactions.</li> </ul>
<p>Visit our <a href="https://docs.netlify.com/resources/checklists/security-checklist#recommended-security-measures">security checklist</a> for general security measures we recommend you consider for your site.</p>
<p>The namespaces you make with <code>getStore</code> are shared across all deploys of your site. This is required when using Netlify CLI and desirable for most use cases with functions and edge functions because it means that a new production deploy can read previously written data without you having to replicate blobs for each new production deploy. This also means you can test your Deploy Previews with production data. This does, however, mean that you should be careful to avoid scenarios such as a branch deploy deleting blobs that your published deploy depends on.</p>
<p>As mentioned above, build plugins and file-based uploads must write to deploy-specific stores. This requirement makes it so that a deploy that fails cannot overwrite production data.</p>
<p>To make a deploy-specific namespace with the Netlify Blobs API, use the <code>getDeployStore</code> method.</p>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions";import { v4 as uuid } from "uuid";export default async (req: Request, context: Context) =&gt; {const uploads = getDeployStore("file-uploads");await uploads.set(key, await req.text());</code></pre></figure>
<figure><pre data-language="ts"><code>import { getDeployStore } from "@netlify/blobs";import type { Context } from "@netlify/edge-functions";import { v4 as uuid } from "uuid";export default async (req: Request, context: Context) =&gt; {const uploads = getDeployStore("file-uploads");await uploads.set(key, await req.text());</code></pre></figure>
<figure><pre data-language="js"><code>import { readFile } from "node:fs/promises";import { getDeployStore } from "@netlify/blobs";import { v4 as uuid } from "uuid";export const onPostBuild = async () =&gt; {const file = await readFile("some-file.txt", "utf8");const uploads = getDeployStore("file-uploads");await uploads.set(key, file);console.log(`Entry added with key ${key}`);</code></pre></figure>
<p>In general, blobs in deploy-specific stores are managed by Netlify like other atomic deploy assets. This means they’re kept in sync with their relative deploys if you do a <a href="https://docs.netlify.com/deploy/manage-deploys/manage-deploys-overview#rollbacks">rollback</a> and that they’re cleaned up with <a href="https://docs.netlify.com/deploy/manage-deploys/manage-deploys-overview#automatic-deploy-deletion">automatic deploy deletion</a>.</p>
<p>However, <a href="https://docs.netlify.com/deploy/manage-deploys/manage-deploys-overview#download-a-deploy">downloading a deploy</a> does not download deploy-specific blobs, and <a href="https://docs.netlify.com/deploy/manage-deploys/manage-deploys-overview#lock-a-published-deploy">locking a published deploy</a> does not prevent you from writing to associated deploy-specific stores.</p>
<p>By default, deploy-specific stores are located in the same region that your functions have been configured to run in. For a list of available regions, check out these <a href="https://docs.netlify.com/build/functions/optional-configuration#region">region docs</a>.</p>
<p>You can also manually specify which region to connect to, regardless of your function’s region, by passing the region as an option when using the <code>getDeployStore</code> method.</p>
<figure><pre data-language="ts"><code>import { getDeployStore } from "@netlify/blobs";import type { Context } from "@netlify/functions";import { v4 as uuid } from "uuid";export default async (req: Request, context: Context) =&gt; {const uploads = getDeployStore({ name: "file-uploads", region: "ap-southeast-2" });await uploads.set(key, await req.text());</code></pre></figure>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/edge-functions";import { v4 as uuid } from "uuid";export default async (req: Request, context: Context) =&gt; {const uploads = getDeployStore({ name: "file-uploads", region: "ap-southeast-2" });await uploads.set(key, await req.text());</code></pre></figure>
<figure><pre data-language="js"><code>import { readFile } from "node:fs/promises";export const onPostBuild = async () =&gt; {const file = await readFile("some-file.txt", "utf8");const uploads = getDeployStore({ name: "file-uploads", region: "ap-southeast-2" });await uploads.set(key, file);console.log(`Entry added with key ${key}`);</code></pre></figure>
<p>Keep the following requirements in mind while working with Netlify Blobs:</p>
<ul> <li>Netlify Blobs uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">web platform <code>fetch()</code></a> to make HTTP calls, so Fetch API support is required. This is included with Node.js 18. If for some reason you can’t use Node.js 18, you can provide your own Fetch API support by supplying a <code>fetch</code> property to the <code>getStore</code> or <code>getDeployStore</code> method.</li> <li>File-based uploads require <a href="https://docs.netlify.com/deploy/create-deploys#deploy-with-git">continuous deployment</a> or <a href="https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli#manual-deploys">CLI deploys</a>.</li> </ul>
<figure><pre data-language="ts"><code>import type { Context } from "@netlify/functions"&gt;export default async (req: Request, context: Context) =&gt; {const uploads = getStore({ fetch, name: "file-uploads" });const entry = await uploads.get("my-key");</code></pre></figure>
<figure><pre data-language="js"><code>export const onPostBuild = async () =&gt; {const entry = await uploads.get("my-key");console.log(entry);</code></pre></figure>
<p>Keep the following rules in mind when creating namespaces and blobs:</p>
<ul> <li>Store names cannot include the <code>/</code> character.</li> <li>Store names cannot include the <code>:</code> character.</li> <li>Store names cannot exceed 64 bytes.</li> <li>Empty keys are not supported.</li> <li>Object keys can include any Unicode characters.</li> <li>Object keys cannot start with the <code>/</code> character.</li> <li>Object keys cannot exceed 600 bytes.</li> <li>An individual object’s total size cannot exceed 5 GB.</li> <li>An individual object’s metadata size cannot exceed 2 KB.</li> </ul>
<aside> <p><figure></figure></p> <p>Most Unicode characters with UTF-8 encoding take 1 byte. So, for convenience, you can think of the above size limits as roughly a 64-character limit for store names and a 600-character limit for object keys. But, be aware that some characters take more than one byte. For example, <code>à</code> takes 2 bytes.</p> </aside>
<p>Keep the following limitations in mind when working with Netlify Blobs:</p>
<ul> <li>Functions written in Go cannot access Netlify Blobs.</li> <li>Local development with Netlify Dev uses a sandboxed local store that does not support <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#file-based-uploads">file-based uploads</a>. You cannot read production data during local development.</li> <li><a href="https://docs.netlify.com/deploy/manage-deploys/manage-deploys-overview#automatic-deploy-deletion">Deploy deletion</a> deletes deploy-specific stores only. For other stores, you can create <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#expiration-logic">custom expiration logic</a> or <a href="https://docs.netlify.com/build/data-and-storage/netlify-blobs/?_gl=1*x3hasu*_gcl_au*NTgxNTg1NjM1LjE3NTM4MjY4NzIuMjAwODE1Nzk1OS4xNzU1MTE5MTc1LjE3NTUxMTkxNzU.#delete">delete objects manually</a> as needed.</li> <li>Netlify Blobs is not currently supported as part of our HIPAA-compliant hosting offering. For more information, visit our <a href="https://trust-center.netlify-corp.com">Trust Center</a> and download our reference architecture for HIPAA-compliant composable sites on Netlify.</li> </ul>
<ul> <li> <p><strong>Last write wins.</strong> If two overlapping calls try to write the same object, the last write wins. Netlify Blobs does not include a concurrency control mechanism. To manage the potential for race conditions, you can build an object-locking mechanism into your application.</p> </li> <li> <p><strong>Store access depends on <code>@netlify/blobs</code> module version.</strong> If you wrote to site-wide stores with <code>@netlify/blobs</code> version 6.5.0 or earlier, and you then upgrade the module to a more recent version, you will no longer be able to access data in those stores. This is due to an internal change to namespacing logic. You can migrate affected stores by running the following command in the project directory using the latest version of the <a href="https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli">Netlify CLI</a>.</p> <figure><figcaption>Terminal window</figcaption><pre data-language="sh"><code>netlify recipes blobs-migrate YOUR_STORE_NAME</code></pre></figure> <p>This makes the migrated store accessible with <code>@netlify/blobs</code> module version 7.0.0 and later.</p> </li> </ul>
