---
author: Toptal
cover_image: >-
  https://bs-uploads.toptal.io/blackfish-uploads/components/open_graph_image/10276173/og_image/optimized/0116-MemoryLeaksNodeJs-Waldek_Social-9db8e1486ccb23cb11f37bddacb24fd4.png
date: '2025-10-29T17:25:37.658Z'
dateFolder: 2025/10/29
description: >-
  Memory leaks in long running Node.js applications are like ticking time bombs
  that, if left unchecked in production environments, can result in devastating
  outcomes. These bugs are often considered to be hard to find. However, with
  the right tools and a strategic approach, memory leaks can not only be solved
  but als...
isBasedOn: 'https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications'
link: 'https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications'
slug: 2025-10-29-httpswwwtoptalcomnodejsdebugging-memory-leaks-node-js-applications
tags:
  - code
title: Debugging Memory Leaks in Node.js Applications
---
<p>I once drove an Audi with a V8 twin-turbo engine inside, and its performance was incredible. I was driving at around 140MPH on IL-80 highway near Chicago at 3AM when there was nobody on the road. Ever since then, the term “V8” has become associated with high performance to me.</p>
<p>Node.js is a platform built on Chrome's V8 JavaScript engine for easy building of fast and scalable network applications.</p>
<p>Although Audi’s V8 is very powerful, you are still limited with the capacity of your gas tank. The same goes for Google’s V8 - the JavaScript engine behind Node.js. Its performance is incredible and there are many reasons why Node.js <a href="https://www.toptal.com/javascript/why-the-hell-would-i-use-node-js">works well for many use cases</a>, but you’re always limited by the heap size. When you need to process more requests in your Node.js application you have two choices: either scale vertically or scale horizontally. Horizontal scaling means you have to run more concurrent application instances. When done right, you end up being able to serve more requests. Vertical scaling means that you have to improve your application’s memory usage and performance or increase resources available for your application instance.</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png"/><img alt="Debugging Memory Leaks in Node.js Applications" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129284%2Ftoptal-blog-image-1551790662518-01d2ac8e099c7ec406e0949603394cb1.png"/></picture></figure>
<figure><p class="rw-outer-content"><span>Some content could not be imported from the original document.</span> <a href="https://platform.twitter.com/widgets/tweet_button.2f70fb173b9000da126c79afe2098f02.en.html#dnt=false&amp;id=twitter-widget-0&amp;lang=en&amp;original_referer=https%3A%2F%2Fwww.toptal.com%2Fnodejs%2Fdebugging-memory-leaks-node-js-applications&amp;size=m&amp;text=Debugging%20Memory%20Leaks%20in%20Node.js%20Applications&amp;time=1761758727343&amp;type=share&amp;url=https%3A%2F%2Fwww.toptal.com%2Fnodejs%2Fdebugging-memory-leaks-node-js-applications&amp;via=toptal">View content ↗ </a></p></figure>
<p>Recently I was asked to work on a Node.js application for one of my Toptal clients to fix a memory leak issue. The application, an API server, was intended to be able to process hundreds of thousands of requests every minute. The original application occupied almost 600MB of RAM and therefore we decided to take the hot API endpoints and reimplement them. Overhead becomes very pricey when you need to serve many requests.</p>
<p>For the new API we chose restify with native MongoDB driver and Kue for background jobs. Sounds like a very lightweight stack, right? Not quite. During peak load a new application instance could consume up to 270MB of RAM. Therefore my dream of having two application instances per 1X Heroku Dyno vanished.</p>
<h2>Node.js Memory Leak Debugging Arsenal</h2>
<p>If you search for “how to find leak in node” the first tool you’d probably find is <strong>memwatch</strong>. The original package was abandoned a long time ago and is no longer maintained. However you can easily find newer versions of it in GitHub’s <a href="https://github.com/lloyd/node-memwatch/network">fork list for the repository</a>. This module is useful because it can emit leak events if it sees the heap grow over 5 consecutive garbage collections.</p>
<p>Great tool which allows <a href="https://www.toptal.com/nodejs">Node.js developers</a> to take heap snapshot and inspect them later with Chrome Developer Tools.</p>
<h4>Node-inspector</h4>
<p>Even a more useful alternative to heapdump, because it allows you to connect to a running application, take heap dump and even debug and recompile it on the fly.</p>
<h2>Taking “node-inspector” for a Spin</h2>
<p>Unfortunately, you will not be able to connect to production applications that are running on Heroku, because it does not allow signals to be sent to running processes. However, Heroku is not the only hosting platform.</p>
<p>To experience node-inspector in action, we will write a simple Node.js application using restify and put a little source of memory leak within it. All experiments here are made with Node.js v0.12.7, which has been compiled against V8 v3.28.71.19.</p>
<pre><code>var restify = require('restify');

var server = restify.createServer();

var tasks = [];

server.pre(function(req, res, next) {
  tasks.push(function() {
    return req.headers;
  });

  // Synchronously get user from session, maybe jwt token
  req.user = {
    id: 1,
    username: 'Leaky Master',
  };

  return next();
});

server.get('/', function(req, res, next) {
  res.send('Hi ' + req.user.username);
  return next();
});

server.listen(3000, function() {
  console.log('%s listening at %s', server.name, server.url);
});
</code></pre>
<p>The application here is very simple and has a very obvious leak. The array <em>tasks</em> would grow over application lifetime causing it to slow down and eventually crash. The problem is that we are not only leaking closure but entire request objects as well.</p>
<p>GC in V8 employs stop-the-world strategy, therefore it means more objects you have in memory the longer it will take to collect garbage. On log below you can clearly see that in the beginning of the application life it would take an average of 20ms to collect the garbage, but few hundred thousand requests later it takes around 230ms. People who are trying to access our application would have to wait <strong>230ms</strong> longer now because of GC. Also you can see that GC is invoked every few seconds which means that every few seconds users would experience problems accessing our application. And delay will grow up until application crashes.</p>
<pre><code>[28093]     7644 ms: Mark-sweep 10.9 (48.5) -&gt; 10.9 (48.5) MB, 25.0 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

[28093]     7717 ms: Mark-sweep 10.9 (48.5) -&gt; 10.9 (48.5) MB, 18.0 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

[28093]     7866 ms: Mark-sweep 11.0 (48.5) -&gt; 10.9 (48.5) MB, 23.2 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

[28093]     8001 ms: Mark-sweep 11.0 (48.5) -&gt; 10.9 (48.5) MB, 18.4 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

...

[28093]   633891 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 357.3 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

[28093]   635672 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 331.5 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].

[28093]   637508 ms: Mark-sweep 235.7 (290.5) -&gt; 235.7 (290.5) MB, 357.2 ms [HeapObjectsMap::UpdateHeapObjectsMap] [GC in old space requested].
</code></pre>
<p>These log lines are printed when a Node.js application is started with the <em>–trace_gc</em> flag:</p>
<pre><code>node --trace_gc app.js
</code></pre>
<p>Let us assume that we have already started our Node.js application with this flag. Before connecting the application with node-inspector, we need to send it the SIGUSR1 signal to the running process. If you run Node.js in cluster, make sure you connect to one of the slave processes.</p>
<pre><code>kill -SIGUSR1 $pid # Replace $pid with the actual process ID
</code></pre>
<p>By doing this, we are making the Node.js application (V8 to be precise) enter debugging mode. In this mode, the application automatically opens the port 5858 with <a href="https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol">V8 Debugging Protocol</a>.</p>
<p>Our next step is to run node-inspector which will connect to the debugging interface of the running application and open another web interface on port 8080.</p>
<pre><code>$ node-inspector
Node Inspector v0.12.2
Visit http://127.0.0.1:8080/?ws=127.0.0.1:8080&amp;port=5858 to start debugging.
</code></pre>
<p>In case the application is running on production and you have a firewall in place, we can tunnel remote port 8080 to localhost:</p>
<pre><code>ssh -L 8080:localhost:8080 admin@example.com
</code></pre>
<p>Now you could open your Chrome web browser and get full access to Chrome Development Tools attached to your remote production application. Unfortunately, Chrome Developer Tools will not work in other browsers.</p>
<h3>Let’s Find a Leak!</h3>
<p>Memory leaks in V8 are not real memory leaks as we know them from C/C++ applications. In JavaScript variables do not disappear into the void, they just get “forgotten”. Our goal is to find these forgotten variables and remind them that Dobby is free.</p>
<p>Inside Chrome Developer Tools we have access to multiple profilers. We are particularly interested in <strong>Record Heap Allocations</strong> which runs and takes multiple heap snapshots over time. This gives us a clear peek into which objects are leaking.</p>
<p>Start recording heap allocations and let’s simulate 50 concurrent users on our home page using Apache Benchmark.</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg"/><img alt="Screenshot" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91677%2Ftoptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg"/></picture></figure>
<pre><code>ab -c 50 -n 1000000 -k http://example.com/
</code></pre>
<p>Before taking new snapshots, V8 would perform mark-sweep garbage collection, so we definitely know that there is no old garbage in the snapshot.</p>
<h3>Fixing the Leak on the Fly</h3>
<p>After collecting heap allocation snapshots over a period of <strong>3 minutes</strong> we end up with something like the following:</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg"/><img alt="Screenshot" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91678%2Ftoptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg"/></picture></figure>
<p>We can clearly see that there are some gigantic arrays, a lot of IncomingMessage, ReadableState, ServerResponse and Domain objects as well in heap. Let’s try to analyze the source of the leak.</p>
<p>Upon selecting heap diff on chart from 20s to 40s, we will only see objects which were added after 20s from when you started the profiler. This way you could exclude all normal data.</p>
<p>Keeping note of how many objects of each type are in the system, we expand the filter from 20s to 1min. We can see that the arrays, already quite gigantic, keeps growing. Under “(array)” we can see that there are a lot of objects “(object properties)” with equal distance. Those objects are the source of our memory leak.</p>
<p>Also we can see that “(closure)” objects grow rapidly as well.</p>
<p>It might be handy to look at the strings as well. Under the strings list there are a lot of “Hi Leaky Master” phrases. Those might give us some clue too.</p>
<p>In our case we know that the string ”Hi Leaky Master” could only be assembled under the “GET /” route.</p>
<p>If you open retainers path you will see this string is somehow referenced via <em>req</em>, then there is context created and all this added to some giant array of closures.</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg"/><img alt="Screenshot" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91679%2Ftoptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg"/></picture></figure>
<p>So at this point we know that we have some kind of gigantic array of closures. Let’s actually go and give a name to all our closures at real-time under sources tab.</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg"/><img alt="Screenshot" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91680%2Ftoptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg"/></picture></figure>
<p>After we are done editing the code, we can hit CTRL+S to save and recompile code on the fly!</p>
<p>Now let’s record another <strong>Heap Allocations Snapshot</strong> and see which closures are occupying the memory.</p>
<p>It’s clear that <em>SomeKindOfClojure()</em> is our villain. Now we can see that <em>SomeKindOfClojure()</em> closures are being added to some array named <em>tasks</em> in the global space.</p>
<p>It’s easy to see that this array is just useless. We can comment it out. But how do we free memory the memory already occupied? Very easy, we just assign an empty array to <em>tasks</em> and with the next request it will be overridden and memory will be freed after next GC event.</p>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg"/><img alt="Screenshot" src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F91681%2Ftoptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg"/></picture></figure>
<p><strong>Dobby is free!</strong></p>
<h2>Life of Garbage in V8</h2>
<figure><picture data-testid="picture"><source media="(max-width: 360px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=360, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=360&amp;dpr=2 2x"/><source media="(min-width: 360.1px) and (max-width: 480px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=480, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=480&amp;dpr=2 2x"/><source media="(min-width: 480.1px) and (max-width: 768px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=768, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=768&amp;dpr=2 2x"/><source media="(min-width: 768.1px) and (max-width: 1024px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1024, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1024&amp;dpr=2 2x"/><source media="(min-width: 1024.1px) and (max-width: 1440px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1440, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1440&amp;dpr=2 2x"/><source media="(min-width: 1440.1px) and (max-width: 1920px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1920, https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png&amp;width=1920&amp;dpr=2 2x"/><source media="(min-width: 1920.1px)" srcset="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png"/><img alt="Well, V8 JS does not have memory leaks, only forgotten variables." src="https://assets.toptal.io/images?url=https%3A%2F%2Fuploads.toptal.io%2Fblog%2Fimage%2F129283%2Ftoptal-blog-image-1551790645766-7209b76198c4cf446a60cf7462833ffc.png"/></picture><figcaption>Well, V8 JS does not have memory leaks, only forgotten variables.</figcaption></figure>
<p>Well, V8 JS does not have memory leaks, only forgotten variables.</p>
<figure><p class="rw-outer-content"><span>Some content could not be imported from the original document.</span> <a href="https://platform.twitter.com/widgets/tweet_button.2f70fb173b9000da126c79afe2098f02.en.html#dnt=false&amp;id=twitter-widget-1&amp;lang=en&amp;original_referer=https%3A%2F%2Fwww.toptal.com%2Fnodejs%2Fdebugging-memory-leaks-node-js-applications&amp;size=m&amp;text=Well%2C%20V8%20JS%20does%20not%20have%20memory%20leaks%2C%20only%20forgotten%20variables.&amp;time=1761758727344&amp;type=share&amp;url=https%3A%2F%2Fwww.toptal.com%2Fnodejs%2Fdebugging-memory-leaks-node-js-applications&amp;via=toptal">View content ↗ </a></p></figure>
<p>V8 heap is divided into several different spaces:</p>
<ul> <li> <strong>New Space</strong>: This space is relatively small and has a size of between 1MB and 8MB. Most of the objects are allocated here.</li> <li> <strong>Old Pointer Space</strong>: Has objects which may have pointers to other objects. If object survives long enough in New Space it gets promoted to Old Pointer Space.</li> <li> <strong>Old Data Space</strong>: Contains only raw data like strings, boxed numbers and arrays of unboxed doubles. Objects that have survived GC in the New Space for long enough are moved here as well.</li> <li> <strong>Large Object Space</strong>: Objects which are too big to fit in other spaces are created in this space. Each object has it’s own <code>mmap</code>‘ed region in memory</li> <li> <strong>Code space</strong>: Contains assembly code generated by the JIT compiler.</li> <li> <strong>Cell space, property cell space, map space</strong>: This space contains <code>Cell</code>s, <code>PropertyCell</code>s, and <code>Map</code>s. This is used to simplify garbage collection.</li> </ul>
<p>Each space is composed of pages. A page is a region of memory allocated from the operating system with mmap. Each page is always 1MB in size except for pages in large object space.</p>
<p>V8 has two built in garbage collection mechanisms: Scavenge, Mark-Sweep and Mark-Compact.</p>
<p>Scavenge is a very fast garbage collection technique and operates with objects in <strong>New Space</strong>. Scavenge is the implementation of <a href="https://en.wikipedia.org/wiki/Cheney's_algorithm">Cheney’s Algorithm</a>. The idea is very simple, <strong>New Space</strong> is divided in two equal semi-spaces: To-Space and From-Space. Scavenge GC occurs when To-Space is full. It simply swaps To and From spaces and copy all live objects to To-Space or promote them to one of the old spaces if they survived two scavenges, and is then entirely erased from the space. Scavenges are very fast however they have the overhead of keeping double sized heap and constantly copying objects in memory. The reason to use scavenges is because most objects die young.</p>
<p>Mark-Sweep &amp; Mark-Compact is another type of garbage collector used in V8. The other name is full garbage collector. It marks all live nodes, then sweeps all dead nodes and defragments memory.</p>
<h3>GC Performance and Debugging Tips</h3>
<p>While for web applications high performance might not be such a big problem, you will still want to avoid leaks at all costs. During the mark phase in full GC the application is actually paused until garbage collection is completed. This means the more objects you have in the heap, the longer it will take to perform GC and the longer users will have to wait.</p>
<h4>Always give names to closures and functions</h4>
<p>It’s much easier to inspect stack traces and heaps when all your closures and functions have names.</p>
<pre><code>db.query('GIVE THEM ALL', function GiveThemAllAName(error, data) {
    ...
})
</code></pre>
<h4>Avoid large objects in hot functions</h4>
<p>Ideally you want to avoid large objects inside of hot functions so that all data is fit into <strong>New Space</strong>. All CPU and memory bound operations should be executed in background. Also avoid deoptimization triggers for hot functions, optimized hot function uses less memory than non-optimized ones.</p>
<h4>Hot functions should be optimized</h4>
<p>Hot functions that run faster but also consume less memory cause GC to run less often. V8 provides some helpful debugging tools to spot non-optimized functions or deoptimized functions.</p>
<h4>Avoid polymorphism for IC’s in hot functions</h4>
<p>Inline Caches (IC) are used to speed up execution of some chunks of code, either by caching object property access <code>obj.key</code> or some simple function.</p>
<pre><code>function x(a, b) {
  return a + b;
}

x(1, 2); // monomorphic
x(1, “string”); // polymorphic, level 2
x(3.14, 1); // polymorphic, level 3
</code></pre>
<p>When <em>x(a,b)</em> is run for the first time, V8 creates a monomorphic IC. When you call <code>x</code> a second time, V8 erases the old IC and creates a new polymorphic IC which supports both types of operands integer and string. When you call IC the third time, V8 repeats the same procedure and creates another polymorphic IC of level 3.</p>
<p>However, there is a limitation. After IC level reaches 5 (could be changed with <em>–max_inlining_levels</em> flag) the function becomes megamorphic and is no longer considered optimizable.</p>
<p>It’s intuitively understandable that monomorphic functions run the fastest and also have a smaller memory footprint.</p>
<h4>Don’t add large files to memory</h4>
<p>This one is obvious and well known. If you have large files to process, for example a large CSV file, read it line-by-line and process in little chunks instead of loading the entire file to memory. There are rather rare cases where a single line of csv would be larger than 1mb, thus allowing you to fit it in <strong>New Space</strong>.</p>
<h4>Do not block main server thread</h4>
<p>If you have some hot API which takes some time to process, such as an API to resize images, move it to a separate thread or turn it into a background job. CPU intensive operations would block main thread forcing all other customers to wait and keep sending requests. Unprocessed request data would stack in memory, thus forcing full GC to take longer time to finish.</p>
<h4>Do not create unnecessary data</h4>
<p>I once had a weird experience with restify. If you send a few hundred thousand requests to an invalid URL then the application memory would rapidly grow on up to hundred megabytes until a full GC kicks in a few seconds later, which is when everything would go back to normal. Turns out that for each invalid URL, restify generates a new error object which includes long stack traces. This forced newly created objects to be allocated in <strong>Large Object Space</strong> rather than in <strong>New Space</strong>.</p>
<p>Having access to such data could be very helpful during development, but obviously not required on production. Therefore the rule is simple - do not generate data unless you certainly need it.</p>
<h4>Know your tools</h4>
<p>Last, but certainly not the least, is to know your tools. There are various debuggers, leak cathers, and usage graphs generators. All those tools can help you make your software faster and more efficient.</p>
<h2>Conclusion</h2>
<p>Understanding how V8’s garbage collection and code optimizer works is a key to application performance. V8 compiles JavaScript to native assembly and in some cases well written code could achieve performance comparable with GCC compiled applications.</p>
<p>And in case you are wondering, the new API application for my Toptal client, although there is room for improvement, is working very well!</p>
<p><em>Joyent recently released a new version of Node.js which uses one of the latest versions of V8. Some applications written for Node.js v0.12.x may not be compatible with the new v4.x release. However, applications will experience tremendous performance and memory usage improvement within the new version of Node.js.</em></p>
